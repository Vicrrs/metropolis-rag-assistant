Registry — DeepStream documentationSkip to main contentBack to topCtrl+KDeepStream documentationDeepStream documentationTable of ContentsDeepStream Getting StartedWelcome to the DeepStream DocumentationMigration GuideInstallationQuickstart GuideDocker ContainersDeepStream SamplesC/C++ Sample Apps Source DetailsPython Sample Apps and Bindings Source DetailsDeepStream Reference Application - deepstream-appDeepStream Reference Application - deepstream-test5 appDeepStream Reference Application - deepstream-nmos appDeepStream Reference Application on GitHubSample Configurations and StreamsImplementing a Custom GStreamer Plugin with OpenCV Integration ExampleTAO toolkit Integration with DeepStreamTAO Toolkit Integration with DeepStreamTutorials and How-to'sDeepStream-3D Custom Apps and Libs TutorialsDeepStream PerformancePerformanceDeepStream AccuracyAccuracy Tuning ToolsDeepStream Custom ModelUsing a Custom Model with DeepStreamDeepStream Key FeaturesDeepStream-3D Sensor Fusion Multi-Modal Application and FrameworkDeepStream-3D Multi-Modal BEVFusion SetupDeepStream-3D Multi-Modal V2XFusion SetupSmart Video RecordIoTOn the Fly Model UpdateNTP Timestamp in DeepStreamAV Sync in DeepStreamDeepStream With REST API SeverDeepStream 3D Action Recognition AppDeepStream 3D Depth Camera AppDeepStream 3D Lidar Inference AppNetworked Media Open Specifications (NMOS) in DeepStreamGst-nvdspostprocess in DeepStreamDeepStream Can Orientation AppDeepStream Application MigrationApplication Migration to DeepStream 7.1 from DeepStream 7.0DeepStream Plugin GuideGStreamer Plugin OverviewMetaData in the DeepStream SDKGst-nvdspreprocess (Alpha)Gst-nvinferGst-nvinferserverGst-nvtrackerGst-nvstreammuxGst-nvstreammux NewGst-nvstreamdemuxGst-nvmultistreamtilerGst-nvdsosdGst-nvdsmetautilsGst-nvdsvideotemplateGst-nvdsaudiotemplateGst-nvvideoconvertGst-nvdewarperGst-nvofGst-nvofvisualGst-nvsegvisualGst-nvvideo4linux2Gst-nvjpegdecGst-nvimagedecGst-nvjpegencGst-nvimageencGst-nvmsgconvGst-nvmsgbrokerGst-nvdsanalyticsGst-nvdsudpsrcGst-nvdsudpsinkGst-nvdspostprocess (Alpha)Gst-nvds3dfilterGst-nvds3dbridgeGst-nvds3dmixerGst-NvDsUcxGst-nvdsxferGst-nvvideotestsrcGst-nvmultiurisrcbinGst-nvurisrcbinDeepStream Troubleshooting and FAQTroubleshootingFrequently Asked QuestionsDeepStream On WSL2DeepStream On WSLFAQ for Deepstream On WSLDeepStream API GuideDeepStream API GuidesDeepStream Service MakerWhat is Deepstream Service MakerService Maker for C/C++ DevelopersService Maker for Python Developers(alpha)Quick Start GuideIntroduction to Flow APIsIntroduction to Pipeline APIsAdvanced FeaturesMigrating Traditional Deepstream Apps to Service Maker Apps in PythonWhat is a Deepstream Service Maker PluginDeepstream LibrariesDeepStream Libraries (Developer Preview)Graph ComposerOverviewPlatformsSupported platformsGetting StartedApplication Development WorkflowCreating an AI ApplicationReference graphsExtension Development WorkflowDeveloping Extensions for DeepStreamDeepStream ComponentsGXF InternalsGXF InternalsGraph eXecution EngineGraph Execution EngineGraph Composer ContainersGraph Composer and GXF ContainersGXF Component InterfacesGXF Component InterfacesGXF Application API'sGXF App C++ APIsGXF App Python APIsGXF Runtime API'sGXF Core C++ APIsGXF Core C APIsGXF Core Python APIsExtension ManualExtensionsCudaExtensionGXF Stream SyncStandardExtensionPython CodeletsNetworkExtensionNvTritonExtSerializationExtensionMultimediaExtensionVideoEncoderExtensionVideoDecoderExtensionBehavior TreesUCX ExtensionHttpExtensionGrpcExtensionTensorRTExtensionNvDs3dProcessingExtNvDsActionRecognitionExtNvDsAnalyticsExtNvDsBaseExtNvDsCloudMsgExtNvDsConverterExtNvDsDewarperExtNvDsInferenceExtNvDsInferenceUtilsExtNvDsInterfaceExtNvDsMuxDemuxExtNvDsOpticalFlowExtNvDsOutputSinkExtNvDsSampleExtNvDsSampleModelsExtNvDsSourceExtNvDsTemplateExtNvDsTrackerExtNvDsTranscodeExtNvDsTritonExtNvDsUcxExtNvDsUdpExtNvDsVisualizationExtToolsRegistryRegistry Command Line InterfaceComposerContainer BuilderGXF Command Line InterfacePipetuner GuideFAQ GuideFAQDeepStream Legal InformationDeepStream End User License AgreementDeepStream FeedbackFeedback formRegistryRegistry#The Registry is an integral part of the Graph Composer ecosystem and is responsible for providing unified interface between the extensions and tools. Registry service can be accessed using registry CLI:Registry Command Line InterfaceIn the backend, Registry communicates with Nvidia Cloud repository and Local workspace for extension management while it uses local database as cache of extension metadata.Repository Manager#Repository manager is responsible to communicating with NVIDIA Cloud repository or local workspace based on operation or arguments to operation.NVIDIA Cloud Repository#Extensions from Nvidia for public access are published in Nvidia Cloud repository. External users can access these extensions usingregistryreposync-nngc-publiccommand. This command downloads all published extensions metadata to Cache on local disk.Local Workspace#Local workspace is provided forExtension Development Workflow. Registry stores current development version of extension in local workspace. Default workspace path used by Registry is/var/tmp/gxf/.cache/gxf_workspace. It stores only one version so it will overwrite whenever user updates version of extension and adds it to registry.Note/var/tmp/gxf/`is considered as the registry root on local disk which is configurable using theGXF_REGISTRY_ROOTenvironment variable.Cache#Registry maintains metadata for all extensions synchronized from Nvidia Cloud repository or added locally byExtension Development Workflow. It allows quick access to extension metadata on query from tools. Users can clean cache or refresh cache usingRegistry Command Line Interfacecommands. Users has to sync repositories again after cleaning cache to query extension information from registry.Registry maintains two types of cache. The extension metadata contains extension interfaces from all the extensions that were synced along with their corresponding variants which have been uploaded to NGC. This cache is populated by the registry byregistryreposynccommand.
The extension variants are cached by theregistrygraphinstallcommand. The variant archive containing the extension library along with any other headers, source or data files are cached the first time they are downloaded from a NGC repo and reused for subsequentregistrygraphinstalloperations.Note/var/tmp/gxf/is considered as the registry root which is configurable using theGXF_REGISTRY_ROOTenvironment variable. Optionally,registrycache--setcommand can be used to set a specific path for the registry cache.NoteIf Composer is being lauched from a docker, the registry cache from the host can be accessed in the docker by mounting the registry cache path.Sample Command for docker launch: :: docker run -it –rm –net=host –runtime nvidia -e DISPLAY=$DISPLAY -v /tmp/.X11-unix/:/tmp/.X11-unix -v /var/tmp/gxf/.cache/gxf_registry/:/var/tmp/gxf/.cache/gxf_registry/ –privileged <DOCKER-REPOSITORY>:<TAG>Extension Registration#Extension registration adds a new extension to the registry’s cache and default repository.register_extensionmacro can be used to register a new extension with the registry.Mandatory fields:name- Name of the extension registration target. It must followregister_<extension-name>_extnaming convention.extension– Extension target complied using thegraph_cc_extension(…)ruleuuid– Universally unique identifier used to register the extension. Format should follow the standarduuid conventionversion– Extension version. A string that specifies the version of the extension in the following format MAJOR.MINOR.PATCH. Extension developers are expected to follow the semantic versioning concept where a new update in version should follow these guidelines:MAJOR version update when there are API-breaking changesMINOR version update when features are added in backward compatible mannerPATCH version update when bugs are fixed in backward compatible mannerlicense– Extension license. A string naming the type of license associated with the extension. For example – MIT, Apache-2.0, BSD.license_file– Path to a text file which has the complete licensing terms and specifications.Optional fields:url– A link to the web address of the extension projectrepository– A link to the web address of the extension source codelabels– A list of strings which can be used to categorize the extension in NGC. For example,[“nvidia”,“gpu”,“nvgraph”]priority– A value between 0-100 used to indicate the priority of the extension to be used during deployment.target– Target configuration for the extension variant. A dictionary containing the following keys -arch,osanddistribution. If the target info is not specified, it will be automatically deduced based on the bazel build configs used. Accepted values:arch – x86_64, aarch64, sbsaos – linuxdistribution – ubuntu_22.04local_dependencies– A list of registration targets of the dependent repositories. Extensions specified here will be registered prior to the current extension. For example:local_dependencies=["//gxf/sample_extension:register_sample_ext"]compute_dependencies– A list of compute dependencies needed to build the extension library. The required versions of these compute dependencies will be deduced automatically using the bazel build configs used. Accepted values -cuda,cudnn,tensorrt,deepstream,vpi. Example usage:compute_dependencies=["cuda","tensorrt","deepstream"]headers– A list of strings containing the paths to the header files of the extension.binaries– A list of strings containing the paths to any optional binary files the extension needs during deployment.data– A list of strings containing the paths to any optional data files the extension needs during deployment.Onceregister_extensionmacro has been invoked, a manifest file would be auto generated and the registry CLI tool would be used to runextnaddcommand along with the corresponding arguments. This rule further adds this extension to the registry’s local cache and updates the default repository with the extension library, manifest, metadata, and any of the optional files that were specified during registration.
The registration process also generates an output file which contains metadata regarding the extension’s interface. More specifically, it contains information regarding various components and the parameters used in those components, header files, dependencies, labels, author, description etc.Here are the guidelines for registering an extension:x86_64 version of an extension must be registered first before any cross complied (aarch64) variant of the extension is registered. Since the cross complied extension cannot be queried for the extension interface (types of components and parameters) the registry considers the x86_64 variant of the extension as the reference for its interface. In case the cache and/or default repository has been cleaned since the extension was previously registered, the x86_64 variant of the extension must be registered again to repopulate the cache and default repository.If the extension getting registered depends on other extensions in the source code then it must be listed as a dependency in the “dependencies” field. Specifically, the registration target name of the dependent extension must be listed as the dependency so that registry can query the dependent extension’s metadata for its uuid, name and version.If the same extension variant is registered twice, the previously registered variant in the default repository is removed and updated with the contents in the new manifest. Similarly, registering any of the x86_64 variants will update the extension interface in registry cache and hence it is important that extensions interface remains the same across all the variants of the same extension and version.Registering an extension and its variants is only supported on linux x86_64 platforms.Installing graphs for deployment#The registry can also be used to deploy graphs locally or containerize the graph using container builder. To execute a graph using gxe, the registry provides a functionality to prepare a manifest and a corresponding archive package containing all the extensions that are required.An example manifest for the sample graph above is shown here:An example archive for the sample graph above is shown here:To install a graph:Create a graph using the nvgraph composer and save it to the local filesystem.Use thegraphinstallcommand in the CLI tool along with the target platform configuration that decides the variant of the extensions that should be used to for deployment. Registry will auto select the best matching variant for each extension based on the target platform.The output of the graph install command is a gxe manifest along with an archive which contains all the extension libraries and files that were packaged with the extension variant.There’s an option to unpack the deployment package in a local directory which can be used to run the graph locally. Use registry CLI tool withgraphinstall--helpto view all the arguments that are supported.All the extensions used in the graph must be present in the registry’s local cache to install the graph successfully. The version of the extension used in the graph must also match the versions of the extension found in the registry cache.Suppose an extension A is listed as a dependency for extension B and extension C. If a graph is created using extensions B and extension C, it needs to be ensured that both B and C are dependent on the same version of extension A and that version of extension A should be synchronized with the registry to install the graph. Using multiple versions of the same extension in a graph is not supported and is not advisable to create such dependencies.The registry performs version management while installing graphs to ensure the latest versions of extensions are being deployed. Suppose a graph was created using version 1.0.0 of extension A, while there was a newer version of extension 1.1.0 available duringgraphinstallstage. It is ensured only the latest minor.patch version corresponding to the same major of the extension is added in the archive.previousNvDsVisualizationExtnextRegistry Command Line InterfaceOn this pageRepository ManagerNVIDIA Cloud RepositoryLocal WorkspaceCacheExtension RegistrationInstalling graphs for deploymentPrivacy Policy|Manage My Privacy|Do Not Sell or Share My Data|Terms of Service|Accessibility|Corporate Policies|Product Security|ContactCopyright © 2024-2025, NVIDIA Corporation.Last updated on Jan 13, 2025.