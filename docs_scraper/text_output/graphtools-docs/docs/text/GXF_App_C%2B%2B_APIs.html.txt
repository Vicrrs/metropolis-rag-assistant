GXF App C++ APIs — DeepStream documentationSkip to main contentBack to topCtrl+KDeepStream documentationDeepStream documentationTable of ContentsDeepStream Getting StartedWelcome to the DeepStream DocumentationMigration GuideInstallationQuickstart GuideDocker ContainersDeepStream SamplesC/C++ Sample Apps Source DetailsPython Sample Apps and Bindings Source DetailsDeepStream Reference Application - deepstream-appDeepStream Reference Application - deepstream-test5 appDeepStream Reference Application - deepstream-nmos appDeepStream Reference Application on GitHubSample Configurations and StreamsImplementing a Custom GStreamer Plugin with OpenCV Integration ExampleTAO toolkit Integration with DeepStreamTAO Toolkit Integration with DeepStreamTutorials and How-to'sDeepStream-3D Custom Apps and Libs TutorialsDeepStream PerformancePerformanceDeepStream AccuracyAccuracy Tuning ToolsDeepStream Custom ModelUsing a Custom Model with DeepStreamDeepStream Key FeaturesDeepStream-3D Sensor Fusion Multi-Modal Application and FrameworkDeepStream-3D Multi-Modal BEVFusion SetupDeepStream-3D Multi-Modal V2XFusion SetupSmart Video RecordIoTOn the Fly Model UpdateNTP Timestamp in DeepStreamAV Sync in DeepStreamDeepStream With REST API SeverDeepStream 3D Action Recognition AppDeepStream 3D Depth Camera AppDeepStream 3D Lidar Inference AppNetworked Media Open Specifications (NMOS) in DeepStreamGst-nvdspostprocess in DeepStreamDeepStream Can Orientation AppDeepStream Application MigrationApplication Migration to DeepStream 7.1 from DeepStream 7.0DeepStream Plugin GuideGStreamer Plugin OverviewMetaData in the DeepStream SDKGst-nvdspreprocess (Alpha)Gst-nvinferGst-nvinferserverGst-nvtrackerGst-nvstreammuxGst-nvstreammux NewGst-nvstreamdemuxGst-nvmultistreamtilerGst-nvdsosdGst-nvdsmetautilsGst-nvdsvideotemplateGst-nvdsaudiotemplateGst-nvvideoconvertGst-nvdewarperGst-nvofGst-nvofvisualGst-nvsegvisualGst-nvvideo4linux2Gst-nvjpegdecGst-nvimagedecGst-nvjpegencGst-nvimageencGst-nvmsgconvGst-nvmsgbrokerGst-nvdsanalyticsGst-nvdsudpsrcGst-nvdsudpsinkGst-nvdspostprocess (Alpha)Gst-nvds3dfilterGst-nvds3dbridgeGst-nvds3dmixerGst-NvDsUcxGst-nvdsxferGst-nvvideotestsrcGst-nvmultiurisrcbinGst-nvurisrcbinDeepStream Troubleshooting and FAQTroubleshootingFrequently Asked QuestionsDeepStream On WSL2DeepStream On WSLFAQ for Deepstream On WSLDeepStream API GuideDeepStream API GuidesDeepStream Service MakerWhat is Deepstream Service MakerService Maker for C/C++ DevelopersService Maker for Python Developers(alpha)Quick Start GuideIntroduction to Flow APIsIntroduction to Pipeline APIsAdvanced FeaturesMigrating Traditional Deepstream Apps to Service Maker Apps in PythonWhat is a Deepstream Service Maker PluginDeepstream LibrariesDeepStream Libraries (Developer Preview)Graph ComposerOverviewPlatformsSupported platformsGetting StartedApplication Development WorkflowCreating an AI ApplicationReference graphsExtension Development WorkflowDeveloping Extensions for DeepStreamDeepStream ComponentsGXF InternalsGXF InternalsGraph eXecution EngineGraph Execution EngineGraph Composer ContainersGraph Composer and GXF ContainersGXF Component InterfacesGXF Component InterfacesGXF Application API'sGXF App C++ APIsGXF App Python APIsGXF Runtime API'sGXF Core C++ APIsGXF Core C APIsGXF Core Python APIsExtension ManualExtensionsCudaExtensionGXF Stream SyncStandardExtensionPython CodeletsNetworkExtensionNvTritonExtSerializationExtensionMultimediaExtensionVideoEncoderExtensionVideoDecoderExtensionBehavior TreesUCX ExtensionHttpExtensionGrpcExtensionTensorRTExtensionNvDs3dProcessingExtNvDsActionRecognitionExtNvDsAnalyticsExtNvDsBaseExtNvDsCloudMsgExtNvDsConverterExtNvDsDewarperExtNvDsInferenceExtNvDsInferenceUtilsExtNvDsInterfaceExtNvDsMuxDemuxExtNvDsOpticalFlowExtNvDsOutputSinkExtNvDsSampleExtNvDsSampleModelsExtNvDsSourceExtNvDsTemplateExtNvDsTrackerExtNvDsTranscodeExtNvDsTritonExtNvDsUcxExtNvDsUdpExtNvDsVisualizationExtToolsRegistryRegistry Command Line InterfaceComposerContainer BuilderGXF Command Line InterfacePipetuner GuideFAQ GuideFAQDeepStream Legal InformationDeepStream End User License AgreementDeepStream FeedbackFeedback formGXF App C++ APIsGXF App C++ APIs#Arg#structnvidia::gxf::ArgInfo#Holds type information of an Arg.gxf_parameter_type_ttype#The type of the Arg.std::stringtype_name#The name of the Arg’s type.int32_trank#The rank of the Arg.std::array<int32_t,ParameterInfo<int32_t>::kMaxRank>shape#The shape of the Arg.structnvidia::gxf::ArgOverride#A template struct for overriding ArgInfo for various Arg types.staticExpected<void>apply(ArgInfo&info)#Applies the ArgOverride to the given ArgInfo.Parameters:ArgInfo& info– The ArgInfo to apply the override to.Returns:Expected<void> Success or error code on failurestaticExpectedYAML::Nodewrap(constT&value)#Wraps the given arg value in a YAML node.Parameters:const T& value– The value to wrap.Returns:An Expected with a YAML node on success, or an Unexpected with an error code on failure.The following template specializations have been implemented for the ArgOverride struct in arg.hpp:ArgOverride<T>ArgOverride<Handle<T>>ArgOverride<std::vector<T>>ArgOverride<std::array<T,N>>ArgOverride<ProxyComponent>These specializations cover a wide range of parameter types, including scalar types, handles, arrays, vectors, and proxy components.classnvidia::gxf::Arg#Argument interface to enable configuring parameters in GXF Components from the application layer.
All parameter types from :cpp:enum::gxf_parameter_type_tenum is supported.Arg(conststd::string&key)#Constructor for an argument with a given key.template<typenameT>Arg(conststd::string&key,constT&value)#Constructor for an argument with a given key and value.Arg(conststd::string&key,constchar*value)#Constructor for an argument with a given key and string literal value.template<typenameT>Arg(conststd::string&key,constHandle<T>&value,)#Constructor for an argument with a given key and handle to a component as value.Arg(conststd::string&key,constProxyComponent&value)#Constructor for an argument with a given key and a proxy component.template<typenameT,typename=std::enable_if_t<!std::is_lvalue_reference<T>::value>>Arg(conststd::string&key,T&&value,)#Constructor for an argument with a given key and rvalue reference to a value.template<typenameT,typename=std::enable_if_t<!std::is_lvalue_reference<T>::value>>Arg(conststd::string&key,Handle<T>&&value,)#Constructor for an argument with a given key and rvalue reference to a handle to a component as value.Arg(conststd::string&key,ProxyComponent&&value)#Constructor for an argument with a given key and rvalue reference to a proxy component.template<typenameT,typename=std::enable_if_t<!std::is_same_v<Arg,std::decay_t<T>>>>Arg&operator=(constT&value,)#Assignment operator for an argument with a given value.template<typenameT,typename=std::enable_if_t<!std::is_same_v<Arg,std::decay_t<T>>>>Arg&operator=(constHandle<T>&value,)#Assignment operator for an argument with a given handle to a component as value.Arg&operator=(ProxyComponent&value)#Assignment operator for an argument with a given proxy component.template<typenameT,typename=std::enable_if_t<!std::is_same_v<Arg,std::decay_t<T>>&&!std::is_lvalue_reference<T>::value>>Arg&&operator=(T&&value,)#Move assignment operator for an argument with a given rvalue reference to a value.template<typenameT,typename=std::enable_if_t<!std::is_same_v<Arg,std::decay_t<Handle<T>>>&&!std::is_lvalue_reference<Handle<T>>::value>>Arg&&operator=(Handle<T>&&value,)#Move assignment operator for an argument with a given rvalue reference to a handle to a component as value.Arg&&operator=(ProxyComponent&&value)#Move assignment operator for an argument with a given rvalue reference to a proxy component.template<typenameT,typename=std::enable_if_t<IsDefaultConstructible_v<T>>>Tas()const#Method to retrieve the value of the argument as a given type.constgxf_uid_thandle_uid()const#Method to retrieve the handle UID of the argument.constgxf_tid_thandle_tid()const#Method to retrieve the handle TID of the argument.constchar*key()const#Method to retrieve the key of the argument.conststd::stringarg_type_name()const#Method to retrieve the type name of the argument.constArgInfoarg_info()const#Method to retrieve the argument info of the argument.constYAML::Nodeyaml_node()const#Method to retrieve the YAML node of the argument.constint32_trank()const#Method to retrieve the rank of the argument.conststd::array<int32_t,ParameterInfo<int32_t>::kMaxRank>shape()const#Method to retrieve the shape of the argument.constgxf_parameter_type_tparameter_type()const#Method to retrieve the parameter type of the argument.boolhas_value()const#Method to retrieve the argument has a value assignedstd::anyvalue()const#Method to retrieve the value of the argument in a std::any objectArg Parse#template<typenameT,typenameFirst,typename...Rest>std::vector<T>parseArgsOfType(constFirst&first,constRest&...rest,)#Parses the incoming parameter pack of arguments for objects of type TParameters:T– Type of parameter to be filtered from the parameter packReturns:std::vector<T> List of objects of type TExpected<void>applyArg(Handle<Component>component,constArg&arg)#Parameters:component– Handle to a valid componentarg– Arg to be applied on the componentReturns:Expected<void> Success or error code on failureExpected<Arg>findArg(conststd::vector<Arg>&args,conststd::string&key,constgxf_parameter_type_ttype,)#Parameters:args– Input Arg listkey– Arg key to searchtype– parameter type of the ArgReturns:Expected<Arg> Arg object if found, error code on failureApplication#classnvidia::gxf::Application#A class representing an application for GXF. This class provides a convenient way to create and manage GXF applications imperatively.
Users implement a virtual compose() api where individual building blocks of an application is constructed, configured and connected with each other.Application()#Constructor for an application. This constructor initializes an application with no segments or entities.~Application()#Destructor for an application. This destructor cleans up any resources that were allocated by the application.Application(constApplication&)=delete#Copy constructor for an application. This constructor is deleted to prevent copying of applications.Application&operator=(constApplication&)=delete#Copy assignment operator for an application. This operator is deleted to prevent copying of applications.Application(Application&&)=delete#Move constructor for an application. This constructor is deleted to prevent moving applications.Application&operator=(Application&&)=delete#Move assignment operator for an application. This operator is deleted to prevent moving applications.virtualvoidcompose()#A virtual function that is called to compose the application. This function is where the segments and entities of the application are created and configured.Expected<void>setConfig(conststd::string&file_path)#Function to set the configuration of the application. This function sets the configuration of the application by loading it from a file.Parameters:file_path– Absolute path to the yaml config file for segments distributed executionReturns:Expected<void> Success or error code on failureExpected<void>setConfig(intargc,char**argv)#Function to set the configuration of the application. This function sets the configuration of the application by parsing it from command line arguments.Parameters:argc– CLI argument countargv– CLI argument array, the second is config file path for segments distributed executionReturns:Expected<void> Success or error code on failuretemplate<typenameSegmentT,typename=std::enable_if_t<!std::is_same_v<Segment,std::decay_t<SegmentT>>>>std::shared_ptr<SegmentT>createSegment(constchar*name,)#Function to create a segment in the application. This function creates a new segment in the application with the specified name.
The graph for the segment will be composed() after creation. SegmentT is a valid type segment type.Parameters:name– Name of the segmentReturns:Expected<void> Success or error code on failureExpected<void>loadExtensionManifest(constchar*manifest)#Function to load an extension manifest.Parameters:manifest– path to manifest file with list of extensionsReturns:Expected<void> Success or error code on failureExpected<void>connect(SegmentPtrsource,SegmentPtrtarget,std::vector<SegmentPortPair>port_maps,)#This function connects two segments by mapping their ports. It adds a UCX connection between two entities with many : many tx and rx
Ucx Transmitter and Ucx Receiver components are added to the source and target entities in both of the segments.Parameters:source– Segment with the entity transmitting the messagetarget– Segment with the entity receiving entity. A message available term is added along with the Ucx Receiverport_maps– Segment port map with entity and queue name to be used for connection.Returns:Expected<void> Success or error code on failuregxf_result_tnvidia::gxf::Application::setSegmentSeverity(constchar*name,gxf_severity_tseverity,)#Sets the severity level of the logs (corresponding to GXF_LOG_* logging macros) for a specific segmentParameters:name– The name of the segment.severity– The severity level.Returns:A gxf_result_t indicating success or failure.Expected<void>run()#A blocking api to run the graph. If the application contains multiple segments,
each segment is launched asynchronously and this thread is blocked until each one of the segments have finished execution.
If the graph contains multiple entities, then this thread is blocked until the graph execution is complete.Returns:Expected<void> Success or error code on failureExpected<void>runAsync()#A non blocking api call to run an application. If the application contains multiple segments, each segment is launched asynchronously.Returns:Expected<void> Success or error code on failureExpected<void>interrupt()#A non blocking api to stop all running running segments or entities.Returns:Expected<void> Success or error code on failureExpected<void>wait()#A blocking API to waits until the graph execution has completedReturns:Expected<void> Success or error code on failuretemplate<typename...Args>Expected<void>setWorker(conststd::string&name,Args...args,)#In-place add a GraphWorker Component into Application’s root context, in which case Application’s context should only
hold and run GraphWorker or GraphDriverParameters:name– The name of the GraphWorker.args– The parameter pack of arguments to pass to the GraphWorker constructor.Returns:Expected<void> Success or error code on failuretemplate<typename...Args>Expected<void>setDriver(conststd::string&name,Args...args,)#In-place add a GraphDriver Component into Application’s root context, in which case Application’s context should only
hold and run GraphWorker or GraphDriverParameters:name– The name of the GraphDriver.args– The parameter pack of arguments to pass to the GraphDriver constructor.Returns:Expected<void> Success or error code on failuretemplate<typenameT,typename...Args>std::shared_ptr<T>create_app<T,Args...>(Args&&...args,)#Function to create an application. This function creates a new application with the specified arguments. T is valid application type.Returns:shared_ptr of the newly created application objectSegment#structnvidia::gxf::PortPair#A entity - entity connection specified using tx and rx component names
tx - transmitter component name
rx - receiver component name
The queue names should match the parameter keys of the codelet in the corresponding GraphEntity for a successful connection between the two graph entities.SegmentPortsource#The source SegmentPort in the connection.SegmentPorttarget#The target SegmentPort in the connection.PortPair(constSegmentPort&source,constSegmentPort&target)#Constructor for a PortPair with the given source and target SegmentPorts.SegmentPortgetSource()const#Returns the source SegmentPort in the connection.SegmentPortgetTarget()const#Returns the target SegmentPort in the connection.structnvidia::gxf::SegmentPort#An open port in an segment is specified using entity and queue component names. SegmentPort name is in the format “<Entity Name>.<Queue Name>”Entity Name - name of a graph entity created in the segment
Queue Name - tx or rx component name which should match the parameter keys of the codelet in the corresponding GraphEntity for a successful connectionstd::stringname#The name of the SegmentPort, which is a concatenation of the entity name and queue name.std::stringentity_name#The name of the entity associated with the SegmentPort.std::stringqueue_name#The name of the queue (tx or rx) associated with the SegmentPort.structSegmentPortPair#A segment - segment connection specified using the segment port info
SegmentPort name is in the format “<Entity Name>.<Queue Name>” where the queues are tx or rx components.
tx - SegmentPort in the source segment
rx - SegmentPort in the sink segment
The queue names should match the parameter keys of the codelet in the corresponding GraphEntity for a successful connection between the two segmentsSegmentPortsource#The source SegmentPort in the connection.SegmentPorttarget#The target SegmentPort in the connection.SegmentPortPair(constSegmentPort&source,constSegmentPort&target)#Constructor for a SegmentPortPair with the given source and target SegmentPorts.SegmentPortgetSource()const#Returns the source SegmentPort in the connection.SegmentPortgetTarget()const#Returns the target SegmentPort in the connection.enumnvidia::gxf::SchedulerType#Enum representing the type of scheduler to be used in the application. This enum is primarily used as an input to setScheduler api.enumeratorSchedulerType::kGreedy#A single threaded scheduler that assigns resources to entities in a greedy manner, without considering fairness or priorities.enumeratorSchedulerType::kMultiThread#A scheduler that uses multiple threads to execute entities concurrently.enumeratorSchedulerType::KEventBased#A scheduler that uses an event-based model to schedule entities.SchedulerType Enumeration ConstantsconstexprconstSchedulerTypeGreedy=SchedulerType::kGreedy#constexprconstSchedulerTypeMultiThread=SchedulerType::kMultiThread#constexprconstSchedulerTypeEventBased=SchedulerType::KEventBased#classnvidia::gxf::Segment#Segment is a group of graph entities created in a single GXF runtime context. A segment  will have its own scheduler.
Graph entities in a segment are connected with each other via double buffer transmitter and receiver components.
A segment can also be connected other segments via ucx transmitters and receivers. Segments are created and managed
by the :cpp:class::nvidia::gxf::Applicationclass.Segment()#Default constructor.virtual~Segment()#Default Destructor.Segment(Segment&&)=default#Default move constructor.Segment&operator=(Segment&&)=default#Default move assignment operator.voidcompose()#A virtual function that is called to compose the segment. This function is where the entities are created, connected and configured.template<typenameCodeletT,typename...Args>GraphEntityPtrmakeEntity(constchar*name,Args...args,)#Creates a graph entity with a codelet of type CodeletT along with a parameter pack of Arg & ProxyComponent.
The codelet component will be used to auto populate connection queues and their corresponding scheduling terms.
Args can be used to specify a variable list of components to be created along with the codelet in the graph entity.
Args can also be used to specify a variable list of Arg type to update any parameter values of the codeletParameters:const char* name– The name of the graph entity.Args... args– A parameter pack of Arg or ProxyComponent objects.Returns:A newly created graph entity object with the requested components.template<typename...Args>GraphEntityPtrmakeEntity(constchar*name,Args...args,)#Creates a graph entity without a codelet and with a parameter pack of Arg & ProxyComponent.
Args can be used to specify a variable list of components to be created along with the graph entity.Parameters:const char* name– The name of the graph entity.Args... args– A parameter pack of Arg or ProxyComponent objects.Returns:A newly created graph entity object with the requested components.template<typenameT,typename...Args>ProxyComponentmakeTerm(constchar*name,Args...args,)#Creates a scheduling term of requested type T and applies parameter component values from a parameter pack of arguments.
This api does not create the requested gxf native component. A Proxy component value is returned which has the
type info and arg list needed to create this scheduling term. createFromProxy() api is used to create
this component given any specific GraphEntity. Type T must be derived from nvidia::gxf::SchedulingTerm type.
Args is a parameter pack of arguments / parameter values to be applied to the component.Parameters:const char* name– The name of the component.Returns:A ProxyComponent object.template<typenameT,typename...Args>ProxyComponentmakeResource(constchar*name,Args...args,)#Creates a resource of requested type and applies parameter component values from a parameter pack of arguments.
This api does not create the requested gxf native component. A Proxy component value is returned which has the
type info and arg list needed to create this resource. createFromProxy() api is used to create this
component given any specific GraphEntity. Type T must be derived from nvidia::gxf::ResourceBase type.
Args is a parameter pack of arguments / parameter values to be applied to the component.Parameters:const char* name– The name of the component.Returns:A ProxyComponent object.template<typenameClockT,typename...Args>Handle<Clock>setClock(constchar*name,Args...args,)#Adds a clock component to the segment and applies parameter component values from a parameter pack of arguments.
Type T must be derived from nvidia::gxf::Clock type. Args is a parameter pack of arguments / parameter values
to be applied to the component.Parameters:const char* name– The name of the clock component.Returns:Handle<Clock> Handle to newly created clock component. Null handle if component was not created.template<SchedulerTypeschedulerType,typename...Args>Handle<Scheduler>setScheduler(Args...args,)#Adds a scheduler component to the segment and applies parameter component values from a parameter pack of arguments.
Type T must be derived from nvidia::gxf::Scheduler type. Args is a parameter pack of arguments / parameter values
to be applied to the component.Returns:Handle<Scheduler> Handle to newly created scheduler component. Null handle if component was not created.Handle<Scheduler>setScheduler(constSchedulerType&scheduler,std::vector<Arg>arg_list={},)#Add a scheduler to the segment based on the input SchedulerType enum. If the segment contains a clock component,
the same component will be reused to configure the scheduler. If no clock components are found in the segment,
a new RealTimeClock component will be added to the segment.Parameters:const SchedulerType& scheduler– Type of the scheduler to be added. One of kGreedy, kMultithread or kEventBased.std::vector<Arg> arg_list– A vector of Arg to apply to the component.Returns:A Handle to the newly created scheduler component.Expected<void>connect(GraphEntityPtr&source,GraphEntityPtr&target)#Adds a double buffer queue based connection between two entities with 1:1 tx and rx connectivity.Parameters:GraphEntityPtr& source– The origin graph entity for the connection.GraphEntityPtr& target– The destination graph entity for the connection.Returns:Expected<void> Success or error code on failureExpected<void>connect(GraphEntityPtr&source,GraphEntityPtr&target,PortPairport_pair,)#Adds a single double buffer queue based connection between two entities with a port pair specified.Parameters:GraphEntityPtr& source– The origin graph entity for the connection.GraphEntityPtr& target– The destination graph entity for the connection.PortPair port_pair– The port pair containing information of the connection to be created.Returns:Expected<void> Success or error code on failureExpected<void>nvidia::gxf::Segment::connect(GraphEntityPtr&source,GraphEntityPtr&target,std::vector<PortPair>port_pairs,)#Adds multiple double buffer queue based connections between two entities with many : many tx and rx.
Connections between two graph entities are created sequentially.Parameters:GraphEntityPtr& source– The origin graph entity for the connection.GraphEntityPtr& target– The destination graph entity for the connection.std::vector<PortPair> port_pairs– The list of port pairs containing information of the connections to be created.Returns:Expected<void> Success or error code on failureconstchar*name()const#Fetch the name of the segment.Returns:The name of the segment as a const char*.gxf_context_tcontext()#Fetch the context of a segment.Returns:The context of the segment as a gxf_context_t.Expected<void>activate()#Activates all the graph entities in the segment.Returns:Expected<void> Success or error code on failureExpected<void>deactivate()#Deactivates all the graph entities in the segment.Returns:Expected<void> Success or error code on failureExpected<void>run()#A blocking api to run the segment. This thread is blocked (sleeping) until the segment execution is complete.Returns:Expected<void> Success or error code on failureExpected<void>runAsync()#A non blocking api to execute a segment. API returns immediately after starting the segment execution.
wait() can be used to wait until execution has finished.Returns:Expected<void> Success or error code on failureExpected<void>interrupt()#A non blocking api to stop a previously running segment. Segment is not guaranteed to have stopped when this api returns. wait() can be used to wait until the execution has finished.Returns:Expected<void> Success or error code on failureExpected<void>wait()#A blocking API to wait until the segment execution has completed.Returns:Expected<void> Success or error code on failuregxf_result_tsetSeverity(gxf_severity_tseverity)#Sets the severity level of the logs (corresponding to GXF_LOG* logging macros) for a segmentParameters:gxf_severity_t severity– A valid severity level as defined in gxf_severity_t. Logs corresponding to any level <= severity will be logged.Returns:gxf_result_t On success the function returns GXF_SUCCESS.Expected<void>saveToFile(constchar*filepath)#Saves the segment information containing entities, components and their corresponding parameter values in a yaml representation.Parameters:const char* filepath– path to save the resulting graph yaml fileReturns:Expected<void> Success or error code on failureExpected<void>loadParameterFile(constchar*filepath)#Loads parameters for graph entities composed in the segment / application. YAML file follows the GXF graph specification.Parameters:const char* filepath– path to a valid parameters fileReturns:Expected<void> Success or error code on failureExpected<void>createNetworkContext()#Creates a Network Context in the segment which can be used by UCX Connections added in the application.
A new graph entity with the name “NetworkContext” will be added to the segment context with a UcxContext component
and a corresponding entity and component serializersReturns:Expected<void> Success or error code on failureHandle<Component>createFromProxy(ProxyComponent&component,GraphEntityPtr&entity,)#Creates a component in graph entity based on the type information from the ProxyComponentParameters:ProxyComponent& component– A proxy component objectGraphEntityPtr& entity– A pointer to graph entity to be used for creating the componentReturns:Handle<Component> Handle to newly created component or null handle on failureExpected<void>setup(gxf_context_tsegment_context,constchar*name,std::shared_ptr<DefaultExtension>runtime_ext,)#This function is expected to be called by the application layer to assign a context to the segment and a runtime extension for onthe fly registration of componentsParameters:gxf_context_t segment_context– A valid GXF context to be assigned to the segmentconst char* name– A valid name for the segmentstd::shared_ptr<DefaultExtension> runtime_ext– Pointer to a GXF extension which can be used to register any components at runtimeReturns:Expected<void> Success or error code on failureExpected<void>setName(constchar*name)#Sets the name of the segmentParameters:const char* name– A valid name for the segmentReturns:Expected<void> Success or error code on failureGraph Entity#classnvidia::gxf::GraphEntity#A wrapper over nvidia::gxf::Entity to manage a programmable graph entity.Expected<void>nvidia::gxf::GraphEntity::setup(gxf_context_tcontext,constchar*name,)#Creates a programmable entity with the runtime context and sets its name.Parameters:context– A valid GXF contextname– Name of the graph entityReturns:Expected<void> Success or error code on failuretemplate<typenameT,typename...Args>Handle<T>nvidia::gxf::GraphEntity::add(constchar*name=nullptr,Args...args,)#Creates a generic component of type T and sets the parameter values from Args pack of args. Transmitters, Receivers, Clocks and Scheduling
Term component names have to be unique. Type T must be derived from nvidia::gxf::Component.Parameters:name– Name of the componentargs– Args must be of type ArgReturns:Handle<T> Handle to newly created component. Null handle if component was not created.template<typenameT>Handle<T>nvidia::gxf::GraphEntity::add(constchar*name,std::vector<Arg>arg_list,)#Creates a generic component of type T and sets the parameter values from arg_list. Transmitters, Receivers, Clocks and Scheduling Term
component names have to be unique. Type T must be derived from nvidia::gxf::ComponentParameters:name– Name of the componentarg_list– vector of Arg used for initializing the component’s parameters.Returns:Handle<T> Handle to newly created component. Null handle if component was not created.template<typenameT,size_tN=kMaxComponents>FixedVector<Handle<T>,N>nvidia::gxf::GraphEntity::findAll()const#Finds all components of given type. Returns an empty vector if component is not found. Type T is a type of component to search for.Parameters:N– Maximum number of components to returnReturns:FixedVector<Handle<T>, N> List of handles to components of the same typetemplate<typenameT>Handle<T>nvidia::gxf::GraphEntity::get(constchar*name=nullptr,)const#Gets a component by type and name. Returns null handle if no such component. Type T is a type of component to search for.Parameters:name– Name of the component to look forReturns:Handle<T> Handle to component, if component is found. Null handle if no such component.template<typenameT>Expected<Handle<T>>nvidia::gxf::GraphEntity::try_get(constchar*name=nullptr,)const#Get a component by type and name. Returns an Unexpected in the case that the component is not found. Unlike get no error is logged if a
component is not found. Type T is a type of component to search for.Parameters:name– Name of the component to look forReturns:Expected<Handle<Component>> Handle to the component, if component is found. Otherwise, an Unexpected is returned.Handle<Component>nvidia::gxf::GraphEntity::get(constchar*type_name,constchar*name=nullptr,)const#Gets a component by type and name. Returns null handle if no such component.Parameters:type_name– Fully qualified C++ type name of the component to search forname– Name of the component to look forReturns:Handle<Component> Handle to component, if component is found. Null handle if no such component.template<typenameT>Expected<Handle<T>>nvidia::gxf::GraphEntity::try_get(constchar*type_name,constchar*name=nullptr,)const#Get a component by type and name. Returns an Unexpected in the case that the component is not found.
Unlike get no error is logged if a component is not found. Type T is a type of component to search for.Parameters:type_name– Fully qualified C++ type name of the component to search forname– Name of the component to look forReturns:Expected<Handle<Component>> Handle to the component, if component is found. Otherwise, an Unexpected is returned.template<typenameT,typename...Args>Handle<T>nvidia::gxf::GraphEntity::addCodelet(constchar*name=nullptr,Args...args,)#Adds a codelet of type T with given name and sets the parameter values from Args. T must be derived from nvidia::gxf::Codelet.Parameters:name– Name of the codeletargs– Args must be of type ArgReturns:Handle<T> Handle to newly created codelet. Null handle if component was not created.Handle<Codelet>nvidia::gxf::GraphEntity::addCodelet(constchar*type_name,constchar*name=nullptr,conststd::vector<Arg>&arg_list={},)#Adds a codelet with a given C++ type name.Parameters:type_name– The fully qualified C++ type name of the codelet componentname– Name of the codeletarg_list– Arguments for the codeletReturns:Handle<Codelet> Handle to newly created codelet component. Null handle if component was not created.Handle<Component>nvidia::gxf::GraphEntity::addComponent(constchar*type_name,constchar*name=nullptr,conststd::vector<Arg>&arg_list={},)#Adds a component with a given C++ type name.Parameters:type_name– The fully qualified C++ type name of the componentname– Name of the componentarg_list– Arguments for the componentReturns:Handle<Component> Handle to newly created component. Null handle if component was not created.template<typenameT,typename...Args>Handle<T>nvidia::gxf::GraphEntity::addClock(constchar*name=nullptr,Args...args,)#Adds a component of Clock type T and sets the parameter values from Args. T must be derived from nvidia::gxf::ClockParameters:name– Name of the clockargs– Args must be of type ArgReturns:Handle<T> Handle to newly created clock component. Null handle if component was not created.Handle<Clock>nvidia::gxf::GraphEntity::addClock(constchar*type_name,constchar*name=nullptr,conststd::vector<Arg>&arg_list={},)#Adds a clock component with a given C++ type name.Parameters:type_name– The fully qualified C++ type name of the clockname– Name of the clockarg_list– Arguments for the clock componentReturns:Handle<Clock> Handle to newly created clockHandle<Clock>nvidia::gxf::GraphEntity::getClock(constchar*name=nullptr,)#Get the Clock object from a graph entity. Returns null handle if no clock component has been created yet.
Returns the first clock if no component name is provided. If name is provided, exact instance of the clock is returned if
found else a Null handle.Parameters:name– Name of the clock component to lookupReturns:Handle<Clock>template<typenameT,typename...Args>Handle<T>nvidia::gxf::GraphEntity::addSchedulingTerm(constchar*name=nullptr,Args...args,)#Adds a component of SchedulingTerm type T and sets the parameter values from Args. T must be derived from nvidia::gxf::SchedulingTerm.Parameters:name– name of the scheduling termargs– Args must be of type ArgReturns:Handle<T> Handle to newly created scheduling term componentHandle<SchedulingTerm>nvidia::gxf::GraphEntity::addSchedulingTerm(constchar*type_name,constchar*name=nullptr,conststd::vector<Arg>&arg_list={},)#Adds a scheduling term component with a given C++ type name.Parameters:type_name– The fully qualified C++ type name of the scheduling termname– Name of the scheduling termarg_list– Arguments for the scheduling term componentReturns:Handle<SchedulingTerm> Handle to newly created scheduling termtemplate<typenameT,typename...Args>Handle<T>nvidia::gxf::GraphEntity::addTransmitter(constchar*name,boolomit_term=false,Args...args,)#Adds a component of Transmitter type T with name and sets the parameter values from Args.Name of the transmitter should match the parameter name of the underlying codelet. The name of the transmitter component is updated based on the parameter rank info. A Downstream receptive scheduling term is also added to monitor the transmitter component.If codelet parameter is a scalar, name of the transmitter is also same as the parameter key. Parameter<Handle<Transmitter>> | name - “key”If codelet parameter is a vector/array, the name of the transmitter component is key_%d where ‘d’ is the index of this transmitter in the codelet parameter. Parameter<Vector<Handle<Transmitter>> | name - “key_0”, “key_1”, “key_2”Type T must be derived from nvidia::gxf::Transmitter.Parameters:name– Name of the transmitter componentomit_term– Boolean flag controlling whether or not a default downstream receptive scheduling term is added. If true, no scheduling term is added.args– Args must be of type ArgReturns:Handle<T> Handle to newly created transmitter componentHandle<Transmitter>nvidia::gxf::GraphEntity::addTransmitter(constchar*type_name,constchar*name=nullptr,conststd::vector<Arg>&arg_list={},boolomit_term=false,)#Adds a component of Transmitter of the corresponding type_name.Name of the transmitter should match the parameter name of the underlying codelet. The name of the transmitter component is updated based on the parameter rank info. A Downstream receptive scheduling term is also added to monitor the transmitter component.If codelet parameter is a scalar, name of the transmitter is also same as the parameter key. Parameter<Handle<Transmitter>> | name - “key”If codelet parameter is a vector/array, the name of the transmitter component is key_%d where ‘d’ is the index of this transmitter in the codelet parameter. Parameter<Vector<Handle<Transmitter>> | name - “key_0”, “key_1”, “key_2”Parameters:type_name– The fully qualified C++ type name of the transmitter componentname– Name of the transmitter componentarg_list– Arguments for the transmitter componentomit_term– Boolean flag controlling whether or not a default downstream receptive scheduling term is added. If true, no scheduling term is added.Returns:Handle<Transmitter> Handle to newly created transmitter componentHandle<Transmitter>nvidia::gxf::GraphEntity::getTransmitter(constchar*name,)#Receiver component lookup using nameParameters:name– name of a transmitter component which has been previously createdReturns:Handle<Transmitter> Handle to transmitter component if found, Null handle if no such component.template<typenameT,typename...Args>Handle<T>nvidia::gxf::GraphEntity::addReceiver(constchar*name,boolomit_term=false,Args...args,)#Adds a component of Receiver type T with name and sets the parameter values from Args.Name of the receiver should match the parameter name of the underlying codelet. The name of the receiver component is updated based on the parameter rank info. A Message available scheduling term is also added to monitor the receiver component.If codelet parameter is a scalar, name of the receiver is also same as the parameter key. Parameter<Handle<Receiver>> | name - “key”If codelet parameter is a vector/array, the name of the receiver component is key_%d where ‘d’ is the index of this receiver in the codelet parameter. Parameter<Vector<Handle<Receiver>> | name - “Type T must be derived from nvidia::gxf::Receiver.Parameters:name– Name of the receiver component.omit_term– Boolean flag controlling whether or not a default message available scheduling term is added. If true, no scheduling term is added.args– Args must be of type ArgReturns:Handle<T> Handle to newly created receiver componentHandle<Receiver>addReceiver(constchar*type_name,constchar*name=nullptr,conststd::vector<Arg>&arg_list={},boolomit_term=false,)#Adds a component of Receiver of the corresponding type_name.Name of the receiver should match the parameter name of the underlying codelet. The name of the receiver component is updated based on the parameter rank info.If codelet parameter is a scalar, name of the receiver is also same as the parameter key Parameter<Handle<Receiver>> | name - “key”If codelet parameter is a vector/array, the name of the receiver component is key_%d where ‘d’ is the index of this receiver in the codelet parameter. Parameter<Vector<Handle<Receiver>> | name - “key_0”, “key_1”, “key_2”Parameters:type_name– The fully qualified C++ type name of the receiver.name– Name of the receiver. Default is nullptr.arg_list– Arguments for the receiver component. Default is an empty vector.omit_term– Boolean flag controlling whether or not a default message available scheduling term is added. If true, no scheduling term is added.Returns:Handle<Receiver> Handle to newly created receiver component.Handle<Receiver>getReceiver(constchar*name)#Receiver component lookup using nameParameters:name– name of a receiver component which has been previously createdReturns:Handle to the receiver component if found, Null handle if no such component.Expected<void>configTransmitter(constchar*name,uint64_tcapacity,uint64_tpolicy,uint64_tmin_size,)#Update the capacity and min_size parameter of a transmitter and its corresponding downstream receptive scheduling termParameters:name– Name of the transmitter componentcapacity– capacity of the transmitter to be setpolicy– policy of the transmitter to be setmin_size– min size of the downstream receptive term to be setReturns:Expected<void> Success or error code on failureExpected<void>configReceiver(constchar*name,uint64_tcapacity,uint64_tpolicy,uint64_tmin_size,)#Update the capacity and min_size parameter of a receiver and its corresponding message available scheduling termParameters:name– Name of the receiver componentcapacity– capacity of the receiver to be setpolicy– policy of the receiver to be setmin_size– min size of the message available term to be setReturns:Expected<void> Success or error code on failureExpected<void>activate()#Activate the GraphEntityReturns:Expected<void> Success or error code on failureExpected<void>deactivate()#Deactivate the GraphEntityReturns:Expected<void> Success or error code on failuregxf_context_tcontext()const#Get the context of the GraphEntityReturns:gxf_context_t The context of the GraphEntitygxf_uid_teid()const#Get the entity ID of the GraphEntityReturns:gxf_uid_t The entity ID of the GraphEntityboolis_null()const#Check if the GraphEntity is nullReturns:bool True if the GraphEntity is null, false otherwiseHandle<Codelet>get_codelet()#Get the Codelet associated with the GraphEntityReturns:Handle<Codelet> The Codelet associated with the GraphEntity, or Null handle if none is set.constchar*name()const#Get the name of the entity or an empty string if no name has been given to the entity.Returns:const char* A pointer to the name of the entity.Expected<std::string>formatTxName(constchar*tx_name)#Given a name for a transmitter to be connected to the codelet, return a formatted string back which can be used for a new transmitter component creation. If the codelet’s tx parameter is a scalar, the tx name is the same as the parameter key. If the codelet’s tx parameter is a vector, the tx name would be “key_0”, “key_1” …Parameters:tx_name– name of transmitter componentReturns:Expected<std::string> formatted name of transmitter componentExpected<std::string>formatRxName(constchar*rx_name)#Given a name for a receiver to be connected to the codelet, return a formatted string back which can be used for a new receiver component creation. If the codelet’s rx parameter is a scalar, the rx name is the same as the parameter key. If the codelet’s rx parameter is a vector, the rx name would be “key_0”, “key_1” …Parameters:rx_name– name of receiver componentReturns:Expected<std::string> formatted name of receiver componentExpected<void>updatePort(constchar*key,std::stringvalue)#Update the port with the given key and value.Parameters:key– The key of the port to updatevalue– The new value of the portReturns:Expected<void> Success or error code on failurepreviousGXF Component InterfacesnextGXF App Python APIsOn this pageArgArgInfotypetype_namerankshapeArgOverrideapply()wrap()ArgArg()Arg()Arg()Arg()Arg()Arg()Arg()Arg()operator=()operator=()operator=()operator=()operator=()operator=()as()handle_uid()handle_tid()key()arg_type_name()arg_info()yaml_node()rank()shape()parameter_type()has_value()value()Arg ParseparseArgsOfType()applyArg()findArg()ApplicationApplicationApplication()~Application()Application()operator=()Application()operator=()compose()setConfig()setConfig()createSegment()loadExtensionManifest()connect()setSegmentSeverity()run()runAsync()interrupt()wait()setWorker()setDriver()create_app()SegmentPortPairsourcetargetPortPair()getSource()getTarget()SegmentPortnameentity_namequeue_nameSegmentPortPairsourcetargetSegmentPortPair()getSource()getTarget()SchedulerTypekGreedykMultiThreadKEventBasedGreedyMultiThreadEventBasedSegmentSegment()~Segment()Segment()operator=()compose()makeEntity()makeEntity()makeTerm()makeResource()setClock()setScheduler()setScheduler()connect()connect()connect()name()context()activate()deactivate()run()runAsync()interrupt()wait()setSeverity()saveToFile()loadParameterFile()createNetworkContext()createFromProxy()setup()setName()Graph EntityGraphEntitysetup()add()add()findAll()get()try_get()get()try_get()addCodelet()addCodelet()addComponent()addClock()addClock()getClock()addSchedulingTerm()addSchedulingTerm()addTransmitter()addTransmitter()getTransmitter()addReceiver()addReceiver()getReceiver()configTransmitter()configReceiver()activate()deactivate()context()eid()is_null()get_codelet()name()formatTxName()formatRxName()updatePort()Privacy Policy|Manage My Privacy|Do Not Sell or Share My Data|Terms of Service|Accessibility|Corporate Policies|Product Security|ContactCopyright © 2024-2025, NVIDIA Corporation.Last updated on Jan 13, 2025.