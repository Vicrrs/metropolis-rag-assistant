GXF App Python APIs — DeepStream documentationSkip to main contentBack to topCtrl+KDeepStream documentationDeepStream documentationTable of ContentsDeepStream Getting StartedWelcome to the DeepStream DocumentationMigration GuideInstallationQuickstart GuideDocker ContainersDeepStream SamplesC/C++ Sample Apps Source DetailsPython Sample Apps and Bindings Source DetailsDeepStream Reference Application - deepstream-appDeepStream Reference Application - deepstream-test5 appDeepStream Reference Application - deepstream-nmos appDeepStream Reference Application on GitHubSample Configurations and StreamsImplementing a Custom GStreamer Plugin with OpenCV Integration ExampleTAO toolkit Integration with DeepStreamTAO Toolkit Integration with DeepStreamTutorials and How-to'sDeepStream-3D Custom Apps and Libs TutorialsDeepStream PerformancePerformanceDeepStream AccuracyAccuracy Tuning ToolsDeepStream Custom ModelUsing a Custom Model with DeepStreamDeepStream Key FeaturesDeepStream-3D Sensor Fusion Multi-Modal Application and FrameworkDeepStream-3D Multi-Modal BEVFusion SetupDeepStream-3D Multi-Modal V2XFusion SetupSmart Video RecordIoTOn the Fly Model UpdateNTP Timestamp in DeepStreamAV Sync in DeepStreamDeepStream With REST API SeverDeepStream 3D Action Recognition AppDeepStream 3D Depth Camera AppDeepStream 3D Lidar Inference AppNetworked Media Open Specifications (NMOS) in DeepStreamGst-nvdspostprocess in DeepStreamDeepStream Can Orientation AppDeepStream Application MigrationApplication Migration to DeepStream 7.1 from DeepStream 7.0DeepStream Plugin GuideGStreamer Plugin OverviewMetaData in the DeepStream SDKGst-nvdspreprocess (Alpha)Gst-nvinferGst-nvinferserverGst-nvtrackerGst-nvstreammuxGst-nvstreammux NewGst-nvstreamdemuxGst-nvmultistreamtilerGst-nvdsosdGst-nvdsmetautilsGst-nvdsvideotemplateGst-nvdsaudiotemplateGst-nvvideoconvertGst-nvdewarperGst-nvofGst-nvofvisualGst-nvsegvisualGst-nvvideo4linux2Gst-nvjpegdecGst-nvimagedecGst-nvjpegencGst-nvimageencGst-nvmsgconvGst-nvmsgbrokerGst-nvdsanalyticsGst-nvdsudpsrcGst-nvdsudpsinkGst-nvdspostprocess (Alpha)Gst-nvds3dfilterGst-nvds3dbridgeGst-nvds3dmixerGst-NvDsUcxGst-nvdsxferGst-nvvideotestsrcGst-nvmultiurisrcbinGst-nvurisrcbinDeepStream Troubleshooting and FAQTroubleshootingFrequently Asked QuestionsDeepStream On WSL2DeepStream On WSLFAQ for Deepstream On WSLDeepStream API GuideDeepStream API GuidesDeepStream Service MakerWhat is Deepstream Service MakerService Maker for C/C++ DevelopersService Maker for Python Developers(alpha)Quick Start GuideIntroduction to Flow APIsIntroduction to Pipeline APIsAdvanced FeaturesMigrating Traditional Deepstream Apps to Service Maker Apps in PythonWhat is a Deepstream Service Maker PluginDeepstream LibrariesDeepStream Libraries (Developer Preview)Graph ComposerOverviewPlatformsSupported platformsGetting StartedApplication Development WorkflowCreating an AI ApplicationReference graphsExtension Development WorkflowDeveloping Extensions for DeepStreamDeepStream ComponentsGXF InternalsGXF InternalsGraph eXecution EngineGraph Execution EngineGraph Composer ContainersGraph Composer and GXF ContainersGXF Component InterfacesGXF Component InterfacesGXF Application API'sGXF App C++ APIsGXF App Python APIsGXF Runtime API'sGXF Core C++ APIsGXF Core C APIsGXF Core Python APIsExtension ManualExtensionsCudaExtensionGXF Stream SyncStandardExtensionPython CodeletsNetworkExtensionNvTritonExtSerializationExtensionMultimediaExtensionVideoEncoderExtensionVideoDecoderExtensionBehavior TreesUCX ExtensionHttpExtensionGrpcExtensionTensorRTExtensionNvDs3dProcessingExtNvDsActionRecognitionExtNvDsAnalyticsExtNvDsBaseExtNvDsCloudMsgExtNvDsConverterExtNvDsDewarperExtNvDsInferenceExtNvDsInferenceUtilsExtNvDsInterfaceExtNvDsMuxDemuxExtNvDsOpticalFlowExtNvDsOutputSinkExtNvDsSampleExtNvDsSampleModelsExtNvDsSourceExtNvDsTemplateExtNvDsTrackerExtNvDsTranscodeExtNvDsTritonExtNvDsUcxExtNvDsUdpExtNvDsVisualizationExtToolsRegistryRegistry Command Line InterfaceComposerContainer BuilderGXF Command Line InterfacePipetuner GuideFAQ GuideFAQDeepStream Legal InformationDeepStream End User License AgreementDeepStream FeedbackFeedback formGXF App Python APIsGXF App Python APIs#Node#classNode(ABC)#Abstract base class for Graph, Entity, EntityGroupabstractactivate()#Activate the node and its components.abstractset_params()#Set parameters for the node and its components.Graph#classGraph(Node)#Python class wrapping the nvidia::gxf::Graph.__init__(name:str='')#Initialize the Graph object.Parameters:name(str) – The name of the graph.context:int#The context associated with the graph. If the graph is a subgraph, returns the parent’s context.name:str#The name of the graph.qualified_name:str#The qualified name of the graph, including the parent’s name if the graph is a subgraph.set_name(value)#Set the name of the graph.Parameters:value(str) – The new name for the graph.parent:Graph#The parent graph, if the current graph is a subgraph.set_parent(value)#Set the parent graph, making the current graph a subgraph.Parameters:value(Graph) – The parent graph.aliases:dict#A dictionary of aliases for components in the graph.update_alias(alias,value)#Update the value of an alias.Parameters:alias(str) – The alias to update.value– The new value for the alias.Raises:ValueError– If the alias is not set.set_params()#Set parameters for the graph.get(alias)#Get the value of an alias.Parameters:alias(str) – The alias to retrieve.Returns:The value associated with the alias.Raises:ValueError– If the alias is not marked visible.make_visible(alias,component)#Mark a component as visible with an alias.Parameters:alias(str) – The alias to associate with the component.component– The component to make visible.Raises:RuntimeError– If the alias already exists.is_subgraph:bool#Whether the graph is a subgraph or not.as_subgraph_of(parent)#Make the current graph a subgraph of the given parent graph.Parameters:parent(Graph) – The parent graph.activate()#Activate the graph and its components.add(node)#Add a node (Entity, EntityGroup, or Graph) to the graph.Parameters:node(Entity,EntityGroup, orGraph) – The node to add.Returns:The added node.Raises:RuntimeError– If the node type is not supported.load_extensions(extension_filenames=None,manifest_files=None,workspace='',)#Load GXF extensions for the graph.Uses env variableGXF_WORKSPACEasworkspaceGeneratesextension_filenamesbased on the extensions used in the graph if noextension_filenamesandmanifest_filesare passedParameters:extension_filenames(list,optional) – List of extension library file paths (.sofiles)manifest_files(list,optional) – List of manifest file paths.workspace(str,optional) – Base directory for extensions and manifests.set_severity(log_level=logging.INFO)#Set the severity level for GXF logging.Parameters:log_level(optional,intorabove enum from python logging package) –The logging level to set. Can be one of the following:logging.NOTSET(0): No logging.logging.ERROR(40): Log only error messages.logging.WARN(30): Log warning and error messages.logging.INFO(20): Log informational, warning, and error messages.logging.DEBUG(10): Log debug, informational, warning, and error messages."VERBOSE"(5): Log all messages, including verbose debug messages.Raises:RuntimeError– If an incorrect log level is provided.run()#Run the graph.run_async()#Run the graph asynchronously.interrupt()#Interrupt the graph.wait()#Wait for the graph to complete.destroy()#Destroy the graph and its context.save(filename)#Save the graph to a file.Parameters:filename(str) – The path to save the graph file.Entity#classEntity(Node)#Entity class wrapping the nvidia::gxf::Entity.__init__(name:str='',is_system_entity:bool=False)#Initialize the Entity object.Parameters:name(str) – The name of the entity.is_system_entity(bool) – Whether the entity is a system entity or not.context:int#The context associated with the entity’s graph.components:list#A list of components associated with the entity.named_components:dict#A dictionary of named components associated with the entity.eid:int#The unique identifier of the entity.set_graph(value)#Set the graph associated with the entity.Parameters:value(Graph) – The graph.name:str#The name of the entity.qualified_name:str#The qualified name of the entity, including the graph’s name.is_system_entity:bool#Whether the entity is a system entity or not.set_system_entity_flag(is_system_entity)#Set the system entity flag for the entity.Parameters:is_system_entity(bool) – Whether the entity is a system entity or not.activate()#Activate the entity and its components.set_params()#Set parameters for the entity’s components.add(component,visible_as=None)#Add a component to the entity.Parameters:component(Component) – The component to add.visible_as(str,optional) – An alias to make the component visible in the graph.Returns:The added component.Raises:Exception– If the input is not a Component object.Component#classComponent#Base class for components. Each component from different extensions inherits this class, and overrides:gxf_native_type to its fully qualified C++ type name_validation_info_parameters to its parameter infogxf_native_type:str#Base class variable to be override by the child fully qualified C++ type name._validation_info_parameters:dict#Base class variable to be override by the child parameter info.__init__(type,name,**params)#Initialize the Component object.Parameters:type(str) – The type of the component.name(str) – The name of the component.params(dict) – The parameters for the component.classmethodget_gxf_type()#Get the native GXF type of the component.Returns:The native GXF type.Return type:strname:str#The name of the component.type:str#The type of the component.entity:Entity#The entity associated with the component.params:dict#The parameters of the component.tid:int#The type identifier of the component.cid:int#The unique identifier of the component.context:int#The context associated with the component’s entity.add_to(entity)#Add the component to an entity.Parameters:entity(Entity) – The entity to add the component to.validate_params(params)#Validate the component’s parameters.Parameters:params(dict) – The parameters to validate.Returns:True if the parameters are valid, False otherwise.Return type:boolset_entity(entity)#Set the entity associated with the component.Parameters:entity(Entity) – The entity to associate with the component.Raises:RuntimeError– If the component is already associated with an entity.set_param(param,value)#Set a parameter for the component.Parameters:param(str) – The parameter to set.value– The value to set for the parameter.Raises:ValueError– If the parameter is not found.get_param(param)#Get the value of a parameter for the component.Parameters:param(str) – The parameter to get.Returns:The value of the parameter.Raises:ValueError– If the parameter is not found.set_params()#Set the parameters for the component.EntityGroup#classEntityGroup(Node)#Entity group class wrapping the nvidia::gxf::Entity.__init__(name:str='')#Initialize the EntityGroup object.Parameters:name(str) – The name of the entity group.graph:Graph#The graph associated with the entity group.set_graph(value)#Set the graph associated with the entity group.Parameters:value(Graph) – The graph.context:int#The context associated with the entity group’s graph.name:str#The name of the entity group.qualified_name:str#The qualified name of the entity group, including the graph’s name.add(entities)#Add entities to the group.Parameters:entities(EntityoriterableofEntities) – The entities to add.activate()#Activate the entity group and its entities.set_params()#Set parameters for the entity group.ComputeEntity#classComputeEntity(Entity)#Compute Entity adds an entity in the graph with basic scheduling terms.
A codelet can be added to insert custom user code.__init__(self,name:str='',count:int=-1,recess_period:int=0,**kwargs,)#Initialize a ComputeEntity object.Ifcount>=0, addCountSchedulingTermwith paramcount;Ifrecess_period>0, addPeriodicSchedulingTermwith paramrecess_period;Parameters:name(str) – The name of the compute entity.count(int) – Thecountparameter ofPeriodicSchedulingTerm. A value of -1 indicates the entity can execute indefinitely.recess_period(int) – Therecess_periodparameter ofPeriodicSchedulingTerm. The duration in nanoseconds before the entity is permitted to execute.**kwargs– Additional keyword arguments to be passed to the entity._recess_period:int#_count:int#_kwargs:dict#add_codelet(self,codelet,min_message_available=1,min_message_reception=1,rx_capacity:int=1,tx_capacity:int=1,)→Component#Adds a codelet to the compute entity;Automatically addsTransmitterqueueDoubleBufferTransmitterandDownstreamReceptiveSchedulingTermif the codelet parameter hasnvidia::gxf::Transmitter;Automatically addsReceiverqueueDoubleBufferReceiverandMessageAvailableSchedulingTermif the codelet parameter hasnvidia::gxf::Receiver.Parameters:codelet(Component) – The codelet to be added to the compute entity.min_message_available(int) – The minimum number of messages receiver queue received, only then permit codelet to execute. Skipped if codelet does not have receiver param.min_message_reception(int) – The minimum number of messages transmitter queue can send to downstream, only then permit codelet to execute. Skipped if codelet does not have transmitter param.rx_capacity(int) – The maximum number of messages allowed in the receiver queue. Skipped if codelet does not have receiver param.tx_capacity(int) – The maximum number of messages allowed in the transmitter queue. Skipped if codelet does not have transmitter param.Returns:The added codelet.Return type:ComponentPyComputeEntity#classPyComputeEntity(Entity)#Compute Entity to contain codelet implemented in python. It adds an entity in the graph with basic scheduling terms.
A codelet implemented in python can be added.__init__(self,name:str='',count:int=100,recess_period:int=0,**kwargs,)#Initialize a PyComputeEntity object.Ifcount>=0, addCountSchedulingTermwith paramcount;Ifrecess_period>0, addPeriodicSchedulingTermwith paramrecess_period;Parameters:name(str) – The name of the entity.count(int) – Thecountparameter ofPeriodicSchedulingTerm. A value of -1 indicates the entity can execute indefinitely.recess_period(int) – Therecess_periodparameter ofPeriodicSchedulingTerm. The duration in nanoseconds before the entity is permitted to execute.**kwargs– Additional keyword arguments to be passed to the entity._recess_period:int#_count:int#_kwargs:dict#add_codelet(self,name,codelet,min_message_available=1,min_message_reception=1,rx_capacity:int=1,tx_capacity:int=1,**params,)→Component#Adds a codelet implemented in python to the python compute entity;Automatically addsTransmitterqueueDoubleBufferTransmitterandDownstreamReceptiveSchedulingTermif the codelet parameter hasnvidia::gxf::Transmitter;Automatically addsReceiverqueueDoubleBufferReceiverandMessageAvailableSchedulingTermif the codelet parameter hasnvidia::gxf::Receiver.Parameters:name(str) – The name of the python codelet.codelet(Component) – The python codelet to be added to the compute entity.min_message_available(int) – The minimum number of messages receiver queue received, only then permit codelet to execute. Skipped if codelet does not have receiver param.min_message_reception(int) – The minimum number of messages transmitter queue can send to downstream, only then permit codelet to execute. Skipped if codelet does not have transmitter param.rx_capacity(int) – The maximum number of messages allowed in the receiver queue. Skipped if codelet does not have receiver param.tx_capacity(int) – The maximum number of messages allowed in the transmitter queue. Skipped if codelet does not have transmitter param.Returns:The added python codelet.Return type:Componentstandard_methods#connect(src:Component,target:Component,graph:Graph=None)#Module:gxf.std.standard_methodsConnects two queue components within a graph.Parameters:src(Component) – The source queue component.src– The target queue component.graph(Graph) – The graph that has above two components.enable_job_statistics(g:Graph,name:str='__job_stats',**kwargs,)→Component#Module:gxf.std.standard_methodsAdd aJobStatisticsto a graph.Parameters:g(Graph) – The graph to enable job statistics.name(str) – The name ofJobStatistics.**kwargs– Additional keyword arguments to be passed to theJobStatistics.Returns:The addedJobStatistics.Return type:Componentset_scheduler(g:Graph,sch:Component)→Component#Module:gxf.std.standard_methodsSet aSchedulercomponent to the graph.Parameters:g(Graph) – The graph to setScheduler.sch(Component) – TheSchedulerto set to the graph.Returns:The addedScheduler.Return type:Componentset_clock(g:Graph,clock:Component)→Component#Module:gxf.std.standard_methodsSet a clock component to the graph, so that the components need a clock in the graph can use that clock.Parameters:g(Graph) – The graph to set clock.clock(Component) – The clock to set to the graph.Returns:The added clock.Return type:ComponentGXF_NAME_EXTRA_LENGTH=7Module:gxf.std.standard_methods_generate_name(base_name,extra_length=GXF_NAME_EXTRA_LENGTH)#Module:gxf.std.standard_methodsGenerate a random name with base_name as prefix,{base_name}_*.Parameters:base_name(str) – The name prefix.extra_length(int) – The length of postfix.Returns:The generate random name.Return type:strclassTensor#TheTensorclass represents a multi-dimensional array of elements of the same data type.Protocols implemented:
* DLPack
* array_interface and cuda_array_interface__init__()#Construct a new emptyTensor.staticas_tensor(obj)#Parameters:obj(object) – The input object to be converted to GXF Tensor.Returns:A newTensorinstance initialized with the data from the input object, zero-copy.Return type:TensorCreate a new GXFTensorinstances from various
other deep leanring frameworks,
with data zero-copy if the tensor object support the DLPack protocol,
NumPy’s array interface protocol, or the CUDA array interface protocol.Example:>>>importnumpyasnp>>>arr=np.random.rand(3,4)>>>fromgxf.stdimportTensor>>>tensor=Tensor.as_tensor(arr)staticfrom_dlpack(obj)#Parameters:obj(object) – An object supporting the DLPack protocol.Returns:A newTensorinstance initialized with the data from the input DLPack object, zero-copy.Return type:TensorCreate a newTensorinstance from an object supporting the DLPack protocol.Example:>>>importnumpyasnp>>>arr=np.random.rand(3,4)>>>fromgxf.stdimportTensor>>>tensor=Tensor.from_dlpack(arr)__dlpack__(stream=None)#Parameters:stream(object) – An optional stream object wrapping cuda stream for the DLPack protocol.Returns:A PyCapsule object wrapping DLPack representation of theTensor.__dlpack_device__()#Returns:A PyCapsule object wrapping DLPack device representation of theTensor.get_tensor_info()#Returns:A tuple containing information about theTensor(pointer, size, data type, rank, dimensions, and strides).Get detailed information about theTensorin a tuple format.shape()#Returns:The shape of theTensor.Return type:ShapeGet the shape of theTensor.element_type()#Returns:The element data type of theTensor.Return type:PrimitiveTypeGet the element data type of theTensor.storage_type()#Returns:The storage type of theTensor(kHost or kDevice or kSystem).Return type:MemoryStorageTypeGet the storage type of theTensor.reshape(tensor_description,allocator)#Parameters:tensor_description(gxf.std.TensorDescription) – ATensorDescriptionobject describing the new shape and data type.allocator(Allocator) – AnAllocatorinstance for memory allocation.Reshape theTensoraccording to the providedTensorDescription.reshape_custom(shape,element_type,bytes_per_element,strides,storage_type,allocator,)#Parameters:shape(gxf.std.Shape) – The new shape for theTensor.element_type(gxf.std.PrimitiveType) – The new element data type for theTensor.bytes_per_element(int) – The number of bytes per element in the new data type.strides(list[int]) – The strides for the new shape.storage_type(gxf.std.MemoryStorageType) – The new storage type for theTensor(host or device).allocator(Allocator) – AnAllocatorinstance for memory allocation.Reshape theTensorwith custom parameters.get_tensor_description()#Returns:ATensorDescriptionobject describing the currentTensor.Return type:gxf.std.TensorDescriptionGet aTensorDescriptionobject describing the currentTensor.staticadd_to_entity(entity,tensor=None,name=None)#Parameters:entity– TheEntityto which theTensorshould be added.tensor(Tensor,optional) – An optionalTensorinstance to be added to theEntity. If not provided, a new emptyTensorwill be created.name(str,optional) – An optional name for theTensorcomponent in theEntity.Returns:TheTensorinstance added to theEntity.Return type:Tensorstaticget_from_entity(entity,name=None)#Parameters:entity– TheEntityfrom which to retrieve theTensor.name(str,optional) – The name of theTensorcomponent in theEntity.Returns:TheTensorinstance retrieved from theEntity.Return type:TensorGet aTensorfrom anEntity.find_all_from_entity(entity)#Parameters:entity– TheEntityfrom which to retrieve allTensorinstances.Returns:A list ofTensorinstances retrieved from theEntity.Return type:list[Tensor]Find allTensorinstances in anEntity.previousGXF App C++ APIsnextGXF Core C++ APIsOn this pageNodeNodeactivate()set_params()GraphGraph__init__()contextnamequalified_nameset_name()parentset_parent()aliasesupdate_alias()set_params()get()make_visible()is_subgraphas_subgraph_of()activate()add()load_extensions()set_severity()run()run_async()interrupt()wait()destroy()save()EntityEntity__init__()contextcomponentsnamed_componentseidset_graph()namequalified_nameis_system_entityset_system_entity_flag()activate()set_params()add()ComponentComponentgxf_native_type_validation_info_parameters__init__()get_gxf_type()nametypeentityparamstidcidcontextadd_to()validate_params()set_entity()set_param()get_param()set_params()EntityGroupEntityGroup__init__()graphset_graph()contextnamequalified_nameadd()activate()set_params()ComputeEntityComputeEntity__init__()_recess_period_count_kwargsadd_codelet()PyComputeEntityPyComputeEntity__init__()_recess_period_count_kwargsadd_codelet()standard_methodsconnect()enable_job_statistics()set_scheduler()set_clock()_generate_name()Tensor__init__()as_tensor()from_dlpack()__dlpack__()__dlpack_device__()get_tensor_info()shape()element_type()storage_type()reshape()reshape_custom()get_tensor_description()add_to_entity()get_from_entity()find_all_from_entity()Privacy Policy|Manage My Privacy|Do Not Sell or Share My Data|Terms of Service|Accessibility|Corporate Policies|Product Security|ContactCopyright © 2024-2025, NVIDIA Corporation.Last updated on Jan 13, 2025.