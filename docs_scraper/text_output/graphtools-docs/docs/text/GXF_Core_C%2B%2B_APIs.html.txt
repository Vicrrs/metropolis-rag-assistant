GXF Core C++ APIs — DeepStream documentationSkip to main contentBack to topCtrl+KDeepStream documentationDeepStream documentationTable of ContentsDeepStream Getting StartedWelcome to the DeepStream DocumentationMigration GuideInstallationQuickstart GuideDocker ContainersDeepStream SamplesC/C++ Sample Apps Source DetailsPython Sample Apps and Bindings Source DetailsDeepStream Reference Application - deepstream-appDeepStream Reference Application - deepstream-test5 appDeepStream Reference Application - deepstream-nmos appDeepStream Reference Application on GitHubSample Configurations and StreamsImplementing a Custom GStreamer Plugin with OpenCV Integration ExampleTAO toolkit Integration with DeepStreamTAO Toolkit Integration with DeepStreamTutorials and How-to'sDeepStream-3D Custom Apps and Libs TutorialsDeepStream PerformancePerformanceDeepStream AccuracyAccuracy Tuning ToolsDeepStream Custom ModelUsing a Custom Model with DeepStreamDeepStream Key FeaturesDeepStream-3D Sensor Fusion Multi-Modal Application and FrameworkDeepStream-3D Multi-Modal BEVFusion SetupDeepStream-3D Multi-Modal V2XFusion SetupSmart Video RecordIoTOn the Fly Model UpdateNTP Timestamp in DeepStreamAV Sync in DeepStreamDeepStream With REST API SeverDeepStream 3D Action Recognition AppDeepStream 3D Depth Camera AppDeepStream 3D Lidar Inference AppNetworked Media Open Specifications (NMOS) in DeepStreamGst-nvdspostprocess in DeepStreamDeepStream Can Orientation AppDeepStream Application MigrationApplication Migration to DeepStream 7.1 from DeepStream 7.0DeepStream Plugin GuideGStreamer Plugin OverviewMetaData in the DeepStream SDKGst-nvdspreprocess (Alpha)Gst-nvinferGst-nvinferserverGst-nvtrackerGst-nvstreammuxGst-nvstreammux NewGst-nvstreamdemuxGst-nvmultistreamtilerGst-nvdsosdGst-nvdsmetautilsGst-nvdsvideotemplateGst-nvdsaudiotemplateGst-nvvideoconvertGst-nvdewarperGst-nvofGst-nvofvisualGst-nvsegvisualGst-nvvideo4linux2Gst-nvjpegdecGst-nvimagedecGst-nvjpegencGst-nvimageencGst-nvmsgconvGst-nvmsgbrokerGst-nvdsanalyticsGst-nvdsudpsrcGst-nvdsudpsinkGst-nvdspostprocess (Alpha)Gst-nvds3dfilterGst-nvds3dbridgeGst-nvds3dmixerGst-NvDsUcxGst-nvdsxferGst-nvvideotestsrcGst-nvmultiurisrcbinGst-nvurisrcbinDeepStream Troubleshooting and FAQTroubleshootingFrequently Asked QuestionsDeepStream On WSL2DeepStream On WSLFAQ for Deepstream On WSLDeepStream API GuideDeepStream API GuidesDeepStream Service MakerWhat is Deepstream Service MakerService Maker for C/C++ DevelopersService Maker for Python Developers(alpha)Quick Start GuideIntroduction to Flow APIsIntroduction to Pipeline APIsAdvanced FeaturesMigrating Traditional Deepstream Apps to Service Maker Apps in PythonWhat is a Deepstream Service Maker PluginDeepstream LibrariesDeepStream Libraries (Developer Preview)Graph ComposerOverviewPlatformsSupported platformsGetting StartedApplication Development WorkflowCreating an AI ApplicationReference graphsExtension Development WorkflowDeveloping Extensions for DeepStreamDeepStream ComponentsGXF InternalsGXF InternalsGraph eXecution EngineGraph Execution EngineGraph Composer ContainersGraph Composer and GXF ContainersGXF Component InterfacesGXF Component InterfacesGXF Application API'sGXF App C++ APIsGXF App Python APIsGXF Runtime API'sGXF Core C++ APIsGXF Core C APIsGXF Core Python APIsExtension ManualExtensionsCudaExtensionGXF Stream SyncStandardExtensionPython CodeletsNetworkExtensionNvTritonExtSerializationExtensionMultimediaExtensionVideoEncoderExtensionVideoDecoderExtensionBehavior TreesUCX ExtensionHttpExtensionGrpcExtensionTensorRTExtensionNvDs3dProcessingExtNvDsActionRecognitionExtNvDsAnalyticsExtNvDsBaseExtNvDsCloudMsgExtNvDsConverterExtNvDsDewarperExtNvDsInferenceExtNvDsInferenceUtilsExtNvDsInterfaceExtNvDsMuxDemuxExtNvDsOpticalFlowExtNvDsOutputSinkExtNvDsSampleExtNvDsSampleModelsExtNvDsSourceExtNvDsTemplateExtNvDsTrackerExtNvDsTranscodeExtNvDsTritonExtNvDsUcxExtNvDsUdpExtNvDsVisualizationExtToolsRegistryRegistry Command Line InterfaceComposerContainer BuilderGXF Command Line InterfacePipetuner GuideFAQ GuideFAQDeepStream Legal InformationDeepStream End User License AgreementDeepStream FeedbackFeedback formGXF Core C++ APIsGXF Core C++ APIs#Expected#template<typenameT>usingnvidia::gxf::Expected=nvidia::Expected<T,gxf_result_t>#The Expected type is a template that represents a value that either contains a result of typeTor an error code
of typegxf_result_t. It is used throughout the GXF framework to represent the result of functions that can either
succeed and return a value or fail and return an error code.template<typenameT>nvidia::gxf::Expected<T>nvidia::gxf::Expected(Tvalue,)#Constructs an expected object with a value of type T.Parameters:value– The value to be stored in the Expected object.template<typenameT>nvidia::gxf::Expected<T>nvidia::gxf::Expected(T&&value,)#Constructs an expected object with a value of type T using move construct.Parameters:value– The value to be stored in the Expected object.template<typenameT>boolnvidia::gxf::Expected::has_value()#Returns true if the Expected object contains a value, false otherwise.Returns:True if the Expected object contains a value, false otherwise.template<typenameT>Tnvidia::gxf::Expected::value()#Returns the value of the expected object if it has a valid value, otherwise an assert will be raised if it was constructed using an Unexpected.Returns:The value stored in the Expected object.template<typenameT>gxf_result_tnvidia::gxf::Expected::error()#Returns the error code of the expected object if it was constructed using an Unexpected, otherwise an assert will be raised.Returns:The error code stored in the Expected object.template<typenameT>nvidia::gxf::Unexpected<gxf_result_t>nvidia::gxf::ForwardError(constnvidia::gxf::Expected<T>&expected,)#Extracts the error code as an unexpected.Parameters:expected– The Expected object from which to extract the error code.Returns:The error code stored in the Expected object as an unexpected.template<typenameT>nvidia::gxf::Unexpected<gxf_result_t>nvidia::gxf::ForwardError(nvidia::gxf::Expected<T>&&expected,)#Extracts the error code as an unexpected.Parameters:expected– The Expected object from which to extract the error code.Returns:The error code stored in the Expected object as an unexpected.template<typenameT>gxf_result_tnvidia::gxf::ToResultCode(constnvidia::gxf::Expected<T>&result,)#Interprets an expected as a result code. Returns GXF_SUCCESS if the result has a value and the result’s error code otherwise.Parameters:result– The Expected object to interpret as a result code.Returns:GXF_SUCCESS if the Expected object contains a value, the result’s error code otherwise.nvidia::gxf::Expected<void>nvidia::gxf::ExpectedOrCode(gxf_result_tcode,)#If the result code is GXF_SUCCESS the function returnsnvidia::gxf::Success, otherwise it returns an unexpected with the given error code.Parameters:code– The result code to interpret.Returns:An Expected objecttemplate<typenameT>nvidia::gxf::Expected<std::remove_cv_t<std::remove_reference_t<T>>>nvidia::gxf::ExpectedOrCode(gxf_result_tcode,T&&value,)#If the result code is GXF_SUCCESS the function returns the value, otherwise it returns an unexpected with the given error code.Parameters:code– The result code to interpret.value– Value to be returned when code is GXF_SUCCESSReturns:An Expected objecttemplate<typenameS,typenameT>nvidia::gxf::Expected<std::remove_cv_t<std::remove_reference_t<T>>>nvidia::gxf::ExpectedOrError(constnvidia::gxf::Expected<S>&code,T&&value,)#If the expected code is a valid expected object, the function returns the given value, otherwise it returns the error as an Unexpected.Parameters:code– The expected object to interpret.value– Value to be returned when code has a valid objectReturns:An Expected objecttemplate<typenameS,typenameT>gxf_result_tnvidia::gxf::AccumulateError(gxf_result_tprevious,gxf_result_tcurrent,)#Accumulates the error codes of twonvidia::gxf::gxf_result_tobjects. Returns the first code if it is not a GXF_SUCCESS, else returns the previous codenvidia::gxf::Expected<void>nvidia::gxf::AccumulateError(Expected<void>previous,Expected<void>current,)#Accumulates the error codes of two expected objects. Returns the current object if it has an error, otherwise it returns the previous object.Creating an ExpectedAn Expected can be created in two ways:By constructing it with a value of typeTExpected<int>result{42};By constructing it with an error code of typegxf_result_tExpected<int>result=Unexpected{GXF_OUT_OF_MEMORY};Accessing the Value or Error CodeThe value or error code of an Expected can be accessed using thevalue()anderror()member functions,
respectively. If the Expected contains a value,value()returns that value anderror()returns an error
code of typegxf_result_twith the valueGXF_SUCCESS. If the Expected contains an error code,value()returns an error code of typegxf_result_twith the valueGXF_FAILUREanderror()returns the error code.Expected<int>result{42};intvalue=result.value();// value == 42gxf_result_terror=result.error();// GXF_ASSERT raisedExpected<int>result=Unexpected{GXF_OUT_OF_MEMORY};error=result.error();// error == GXF_OUT_OF_MEMORYvalue=result.value();// GXF_ASSERT raisedChecking if an Expected Contains a ValueThe presence of a value in an Expected can be checked using thehas_value()member function.Expected<int>result{42};if(result.has_value()){// The expected contains a value}else{// The expected contains an error code}Converting an Expected to a Result CodeAn Expected can be converted to a result code using theToResultCode()function. If the Expected contains a value,
the function returnsGXF_SUCCESS. If the Expected contains an error code, the function returns that error code.Expected<int>result{42};gxf_result_tcode=ToResultCode(result);// code == GXF_SUCCESSExpected<int>result=Unexpected{GXF_OUT_OF_MEMORY};code=ToResultCode(result);// code == GXF_OUT_OF_MEMORYCreating an Expected from a Result CodeAn Expected can be created from a result code using theExpectedOrCode()function.
If the result code isGXF_SUCCESS, the function returns an Expected with a value of typeT. If the result
code is notGXF_SUCCESS, the function returns an Expected with the corresponding error code of typegxf_result_t.`gxf_result_tcode=GXF_SUCCESS;intvalue=42;Expected<int>result=ExpectedOrCode(code,42);// result contains a value of type int with the value 42Using Expected with Functions that Return ValuesThe Expected type can be used with functions that return values to simplify error handling. For example, consider the following function that divides
two integers:Expected<int>Divide(intdividend,intdivisor){if(divisor==0){returnUnexpected{GXF_INVALID_ARGUMENT};}returndividend/divisor;}This function returns an Expected with a value of type int if the division is successful, or an error code of typegxf_result_tif
the division is not possible (i.e., if the divisor is zero). The nvidia::gxf::Unexpected type is a template specialization that is used
in conjunction with the nvidia::gxf::Expected template to represent an error state in a result type.To use this function, the caller can check if the Expected contains a value or an error code:Expected<int>result=Divide(42,0);if(result.has_value()){// The division was successfulintvalue=result.value();}else{// The division was not successfulgxf_result_terror=result.error();}Component#classnvidia::gxf::Component#Components are parts of an entity and provide their functionality. The Component class is the
base class of all GXF components. It provides a common interface for creating and managing
components in a GXF entity.virtualgxf_result_tinitialize()=0;#Use to start the lifetime of a component and should be used instead of the constructor.
Called after all components of an entity are created. The order in which components within
the same entity are initialized is undefined.virtualgxf_result_tdeinitialize()=0;#Use to end the lifetime of a component and should be used instead of the deconstructor.
The order in which components within the same entity are deinitialized is undefined.virtualgxf_result_tregisterInterface(Registrar*registrar)=0;#Used to register all parameters of the components. Do not use this function for other
purposes as it might be called at anytime by the runtime.Example:classFoo:publicComponent{public:gxf_result_tregisterInterface(Registrar*registrar)override{registrar->parameter(count_,"count",1);}Parameter<int>count_;};TheregisterInterface()function is used to register the parameters of a
component. It takes a pointer to aRegistrarobject as an argument and
registers all the parameters of the component using one of the overloadedparameterapi’s.
The api supports multiple arguments which include the name of the parameter, unique key identifier,
strings for headline and description of the parameter and also its default value.gxf_context_tcontext()constnoexcept;#Get the context of the component.gxf_uid_teid()constnoexcept;#Get the entity ID of the component.gxf_uid_tcid()constnoexcept;#Get the component ID of the component.gxf_tid_ttid()constnoexcept;#Get the type ID of the component.constchar*type_name()constnoexcept;#Get the type name of the component.Entityentity()constnoexcept;#Get the entity which owns this component.constchar*name()constnoexcept;#Get the name of the component.voidinternalSetup(gxf_context_tcontext,gxf_uid_teid,gxf_uid_tcid,Registrar*registrar,);#This function shall only be called by GXF and is used to setup the component.template<typenameT>Expected<T>getParameter(constchar*key);#Query the value of a component parameter with the given “key” where T is a valid parameter type.Parameters:key– A unique string value used during component registrationReturns:A value of type T for valid key or error code on failureExpected<YAML::Node>wrapParameter(constchar*key);#Wrap the current value of the parameter “key” in a yaml node.Parameters:key– A unique string value used during component registrationReturns:A yaml node with the parameter valuetemplate<typenameT>Expected<void>setParameter(constchar*key,Tvalue,);#Set the parameter “key” with “value” where T is a valid parameter type.Parameters:key– A unique string value used during component registrationvalue– An object of type TReturns:Expected<void> Success or error code on failuretemplate<typenameT>Expected<void>setParameter(constchar*key,Handle<T>&value,);#Set a parameter “key” of handle type with “value” where T is a valid parameter type.Parameters:key– A unique string value used during component registrationvalue– Handle to a component object of type TReturns:Success or error code on failureExpected<void>parseParameter(constchar*key,constYAML::Node&node,std::stringprefix="",);#Set the parameter “key” with the value in yaml node.Parameters:key– A unique string value used during component registrationnode– A yaml node with parameter valueprefix– entity prefix stringReturns:Success or error code on failuretemplate<typenameT>Expected<std::vector<ParameterRegistrar::ComponentParameterInfo>>getParametersOfType();#Query all parameters in the component of type T and return their ComponentParameterInfo struct.Returns:A vector of ComponentParameterInfo of parameters of given typeExpected<ParameterRegistrar::ComponentParameterInfo>getParameterInfo(constchar*key,);#Query ComponentParameterInfo of parameter “key”.virtual~Component()=default;#Destructor.Component(constComponent&component)=delete;#Delete copy constructor. This constructor is deleted to prevent copying of Components.Component(Component&&component)=delete;#Delete move constructor. This constructor is deleted to prevent moving Components.Component&operator=(constComponent&component)=delete;#Delete copy assignment operator. This operator is deleted to prevent copying of Components.Component&operator=(Component&&component)=delete;#Delete move assignment operator. This operator is deleted to prevent moving Components.Entity#classnvidia::gxf::Entity#An entity owns multiple components which define the functionality of the entity. Entities themselves are nothing more than a unique identifier.
Entities created using the C++ type is ref counted. The ref count is automatically decreased when the entity object is destructed or goes out of scope.staticExpected<Entity>New(gxf_context_tcontext,constchar*name=nullptr,)#Creates a new entity using the given context and optionally set the given name.
The caller of this api own’s the object. The reference count is set to 1 and it is
automatically reduced when this object is destroyed or goes out of scope.Parameters:context– The GXF context.name– The name of the entity.Returns:A new entity or an error.staticExpected<Entity>Own(gxf_context_tcontext,gxf_uid_teid,void*item_ptr=nullptr,)#Creates an entity handle based on an existing ID and takes ownership. Reference count is not increased.Parameters:context– The GXF context.eid– The entity ID.item_ptr– An optional entity item pointerReturns:A new entity handle or an error.staticExpected<Entity>Shared(gxf_context_tcontext,gxf_uid_teid,void*item_ptr=nullptr,)#Creates an entity handle based on an existing ID and shares ownership. Reference count is increased by one.Parameters:context– The GXF context.eid– The entity ID.Returns:A new entity handle or an error.Entity()#Construct a new entity object using default constructor. This is a null entity without a valid context of entity ID.Entity(constEntity&other)#Construct a new entity object by copying from another entity object.Entity(Entity&&other)#Construct a new entity object by moving the contents from an existing entity object.~Entity()#Destroy the Entity object. Reduces the reference count by 1.gxf_context_tcontext()const#Returns the GXF context of the entity.gxf_uid_teid()const#Returns the  unique object ID (UID) of the entityboolis_null()const#Checks if an entity object is null (empty)constchar*name()const#The name of the entity or empty string if no name has been given to the entity.Expected<void>activate()#Activates the entity. GxfEntityActivate in gxf.hExpected<void>deactivate()#Deactivates the entity. See GxfEntityDeactivate in gxf.hExpected<Entity>clone()const#Clone an entity from an existing entity object. The returned entity shares the ownership with
the entity being cloned from. Reference count is increased by one.Expected<UntypedHandle>add(gxf_tid_ttid,constchar*name=nullptr)#Adds a component with given type IDParameters:tid– A valid type ID of a registered componentname– Name to be given to the newly created component instanceReturns:An untyped handle to component or error code on failuretemplate<typenameT>Expected<Handle<T>>add(constchar*name=nullptr,)#Adds a component of type T, where T is a registered component type.Parameters:name– Name to be given to the newly created component instanceReturns:A new component handle or an error.Expected<UntypedHandle>get(gxf_tid_ttid,constchar*name=nullptr,)const#Gets a component by type ID. Asserts if no such component.Parameters:tid– A valid type ID of a registered componentname– Name of the component to lookupReturns:An untyped handle to component or error code on failuretemplate<typenameT>Expected<Handle<T>>get(constchar*name=nullptr,)const#Gets a component of type T with given name. Asserts if no such component.Parameters:name– Name of the component to lookupReturns:Typed Handle to the component instance or error on failuretemplate<size_tN=kMaxComponents>Expected<FixedVector<UntypedHandle,N>>findAll()const#Finds all components in an entity. A list of untyped handles of all the components are returned.
N is the capacity of the FixedVector.Returns:A fixed-size vector of untyped component handles allocated on stack or an error.template<typenameT,size_tN=kMaxComponents>Expected<FixedVector<Handle<T>,N>>findAll()const#Finds all components of a given type, where T is a valid type of a registered component and N is the
capacity of the FixedVector.Returns:A fixed-size vector of handles of type T  allocated on stack or an error.template<size_tN=kMaxComponents>Expected<FixedVector<UntypedHandle>>findAllHeap()const#Finds all components in an entity. A fixed-size vector of untyped handles of all the components are returned.Returns:Expected<FixedVector<UntypedHandle, N>> A fixed-size vector of untyped handles of all the components allocated on heaptemplate<typenameT,size_tN=kMaxComponents>Expected<FixedVector<Handle<T>>>findAllHeap()#Finds all components of type T in an entity. A fixed-size vector of typed handles of all the components are returned.Returns:Expected<FixedVector<Handle<T>>> A fixed-size vector of typed handles of given component type allocated on heapExpected<void>remove(gxf_tid_ttid,constchar*name=nullptr)#Removes a component with given type id and nameParameters:tid– A valid type ID of a registered componentname– Name to be given to the newly created component instanceReturns:Expected<void> Success or error code on failuretemplate<typenameT>Expected<void>remove(constchar*name=nullptr,)#Removes a component with given template component type and nameParameters:name– Name of the componentReturns:Expected<void> Success or error code on failureExpected<void>remove(gxf_uid_t&cid)#Removes a component with given uidParameters:cid– A valid uid of the componentReturns:Expected<void> Success or error code on failurevoid*entity_item_ptr()const#Returns the pointer to Entity Item for the entityReturns:void * entity item ptrHandle#UntypedHandle Class#classnvidia::gxf::UntypedHandle#The UntypedHandle class is a base class for Handle and provides common functionality for accessing components without specifying their type.staticUntypedHandleNull()#Returns:A null UntypedHandle object.staticExpected<UntypedHandle>Create(gxf_context_tcontext,gxf_uid_tcid,)#Creates a new untyped handleParameters:context– The context to which the component belongs.cid– The ID of the component.Returns:A new UntypedHandle object for the given context and component ID.gxf_context_tcontext()const#Returns:The context to which the component belongs.gxf_uid_tcid()const#Returns:The ID of the component.gxf_tid_ttid()const#Returns:The type ID describing the component type.boolis_null()const#Returns:True if the handle is equivalent to a nullptr.explicitoperatorbool()const#Returns:True if the handle is not null.constchar*name()const#Returns:The name of the component.UntypedHandle(constUntypedHandle&component)=default#Parameters:component– The UntypedHandle object to copy.UntypedHandle(UntypedHandle&&component)=default#Parameters:component– The UntypedHandle object to move.UntypedHandle&operator=(constUntypedHandle&component)=default#Parameters:component– The UntypedHandle object to copy.UntypedHandle&operator=(UntypedHandle&&component)=default#Parameters:component– The UntypedHandle object to move.Handle Class#classnvidia::gxf::Handle#The Handle class is a template class that derives from UntypedHandle and provides access to components with a specific type.staticHandleNull()#Returns:A null Handle object.staticHandleUnspecified()#An unspecified handle is a unique handle used to denote a component which will be created in the future.
A parameter of Handle to a type does not consider “Unspecified” as a valid parameter value and hence this handle must only be used
when defining a graph application across different files and the parameters are set in a delayed fashion
(sub-graphs and parameter yaml files for example) Entity activation will fail if any of the mandatory parameters are “Unspecified”Returns:An unspecified Handle object.staticExpected<Handle>Create(gxf_context_tcontext,gxf_uid_tcid)#Creates a new handle using the component idParameters:context– The context to which the component belongs.cid– The ID of the component.Returns:A new Handle object for the given context and component ID.staticExpected<Handle>Create(constUntypedHandle&untyped_handle)#Creates a new handle from an untyped handleParameters:untyped_handle– The UntypedHandle object to create a Handle object from.Returns:A new Handle object for the given UntypedHandle object.booloperator==(constHandle&lhs,constHandle&rhs);#Compare if two handle objects are equalReturns:True if the handle objects are pointing to the same componentbooloperator!=(constHandle&lhs,constHandle&rhs);#Compare if two handle objects are not equalReturns:True if the handle objects are not pointing to the same componentbooloperator<(constHandle&lhs,constHandle&rhs);#Compare if an handle object is less than the otherParameters:lhs– typed handle a componentrhs– typed handle a componentReturns:True if the component id of lhs is less than rhstemplate<typenameDerived>Handle(gxf_context_tcontext=kNullContext,gxf_uid_tuid=kNullUid,)#Constructor equivalent to :cpp:func::Handle::CreatefunctionoperatorT*()const#Returns:A pointer to the component of the specific type.T*operator->()const#Returns:A pointer to the component of the specific type.T*get()const#Returns:A pointer to the component of the specific type.Expected<T*>try_get()const#Returns:A pointer to the component of the specific type or an error if the handle is invalid.Handle(constHandle&component)=default#Parameters:component– The Handle object to copy.Handle(Handle&&component)=default#Parameters:component– The Handle object to move.Handle&operator=(constHandle&component)=default#Parameters:component– The Handle object to copy.Handle&operator=(Handle&&component)=default#Parameters:component– The Handle object to move.Parameters#template<typenameT>classParameter#A parameter is a value that can be configured and accessed by a component. It provides a type-safe
and convenient way to manage component attributes.Parameter()#Default constructor. Creates an uninitialized parameter.Returns:An uninitialized parameter.Parameter(constParameter&other)#Copy constructor.Parameters:other– The parameter to copy.Returns:A copy of the other parameter.constT&get()const#Gets the current parameter value. Only valid if the parameter is marked as ‘mandatory’ in the
parameter interface. Otherwise an assert will be raised.Returns:A const reference to the current value of the parameter.operatorconstT&()const#Convenience function for accessing a mandatory parameter as a const reference.Returns:A const reference to the current value of the parameter.Expected<T>try_get()const#Tries to get the current value of the parameter. If the parameter is not set or has an error
value, returns an Unexpected with an error code.Returns:The current value of the parameter, or an Unexpected with an error code.Expected<void>set(Tvalue)#Sets the current value of the parameter. If the value is invalid, returns an Unexpectedwith an error code.Parameters:value– The new value of the parameter.Returns:Expected<void> Success or error code on failurevoidconnect(ParameterBackend<T>*backend)#Connects the parameter to a backend. The backend is responsible for managing the parameter value
and providing access to it.Parameters:backend– The backend to connect to.constchar*key()const#Returns the key of the parameter. The key is a string that identifies the parameter and is used
to look it up in the parameter storage.Returns:The key of the parameter.Expected<void>set_without_propagate(Tvalue)#Sets the current value of the parameter without propagating the change to the backend. This
function should only be used by the ParameterBackend class.Parameters:value– The new value of the parameter.Returns:Expected<void> Success or error code on failureParameter Types#GXF supports multiple parameter types natively as described in :c:enum::gxf_parameter_type_t. All standard C++ data types
are supported including POD types, string, bool, handles to components and complex numbers. ParameterWrapper and ParameterParser
interfaces can be used to support any custom Parameter type.structParameterParser#template<typenameT,typenameV=void>staticExpected<T>Parse(gxf_context_tcontext,gxf_uid_tcomponent_uid,constchar*key,constYAML::Node&node,conststd::string&prefix,)#Parses a parameter of type T from a YAML node.Parameters:context– The GXF context.component_uid– The unique identifier of the component.key– The key of the parameter.node– The YAML node to parse.prefix– The prefix to use when looking up entities.Returns:An Expected containing the parsed parameter or an error code.structParameterWrapper#template<typenameT,typenameV=void>staticExpectedYAML::NodeWrap(gxf_context_tcontext,constT&value,)#Wraps a value of type T in a YAML node.Parameters:context– The GXF context.value– The value to wrap.Returns:An Expected containing the YAML node or an error code.Here is an example to adapt ParameterParser and ParameterWrapper to create an enum parameterExample:// Mode switchenumstructMyEnum{kValue0=0,kValue1=1,};// Custom parameter parser for MyEnumtemplate<>structParameterParser<MyEnum>{staticExpected<MyEnum>Parse(gxf_context_tcontext,gxf_uid_tcomponent_uid,constchar*key,constYAML::Node&node,conststd::string&prefix){conststd::stringvalue=node.as<std::string>();if(strcmp(value.c_str(),"Value0")==0){returnMyEnum::kValue0;}if(strcmp(value.c_str(),"Value1")==0){returnMyEnum::kValue1;}returnUnexpected{GXF_ARGUMENT_OUT_OF_RANGE};}};// Custom parameter wrapper for MyEnumtemplate<>structParameterWrapper<MyEnum>{staticExpected<YAML::Node>Wrap(gxf_context_tcontext,constMyEnum&value){YAML::Nodenode(YAML::NodeType::Scalar);switch(value){caseMyEnum::kValue0:{node=std::string("Value0");break;}caseMyEnum::kValue1:{node=std::string("Value1");break;}default:returnUnexpected{GXF_PARAMETER_OUT_OF_RANGE};}returnnode;}};Parameter Registration#classnvidia::gxf::Registrar#The Registrar class is used to register parameters and resources of a component. The following api’s must be
used within theregisterInterface()function only.template<typenameT>Expected<void>parameter(Parameter<T>&parameter,constchar*key,)#Registers a parameter with the given key, where T is a valid parameter type.Parameters:parameter– The parameter to registerkey– A unique string value used during component registrationReturns:Expected<void> Success or error code on failuretemplate<typenameT>Expected<void>parameter(Parameter<T>&parameter,constchar*key,constchar*headline,)#Registers a parameter with the given key and headline, where T is a valid parameter type.Parameters:parameter– The parameter to registerkey– A unique string value used during component registrationheadline– A brief description of the parameterReturns:Expected<void> Success or error code on failuretemplate<typenameT>Expected<void>parameter(Parameter<T>&parameter,constchar*key,constchar*headline,constchar*description,)#Registers a parameter with the given key, headline and description, where T is a valid parameter type.Parameters:parameter– The parameter to registerkey– A unique string value used during component registrationheadline– A brief description of the parameterdescription– A detailed description of the parameterReturns:Expected<void> Success or error code on failuretemplate<typenameT>Expected<void>parameter(Parameter<T>&parameter,constchar*key,constchar*headline,constchar*description,constT&default_value,)#Registers a parameter with the given key, headline, description, and default value, where T is a valid parameter type.Parameters:parameter– The parameter to registerkey– A unique string value used during component registrationheadline– A brief description of the parameterdescription– A detailed description of the parameterdefault_value– The default value of the parameterReturns:Expected<void> Success or error code on failuretemplate<typenameT>Expected<void>parameter(Parameter<T>&parameter,constchar*key,constchar*headline,constchar*description,constT&default_value,gxf_parameter_flags_tflags,)#Registers a parameter with the given key, headline, description, default value, and flags, where T is a valid parameter type.Parameters:parameter– The parameter to registerkey– A unique string value used during component registrationheadline– A brief description of the parameterdescription– A detailed description of the parameterdefault_value– The default value of the parameterflags– Flags to specify parameter propertiesReturns:Expected<void> Success or error code on failuretemplate<typenameT>Expected<void>parameter(Parameter<T>&parameter,constchar*key,constchar*headline,constchar*description,Unexpected,gxf_parameter_flags_tflags,)#Registers a parameter with the given key, headline, description, and flags, where T is a valid parameter type.
The default value is set to an nvidia::gxf::Unexpected.Parameters:parameter– The parameter to registerkey– A unique string value used during component registrationheadline– A brief description of the parameterdescription– A detailed description of the parameterflags– Flags to specify parameter propertiesReturns:Expected<void> Success or error code on failuretemplate<typenameT>Expected<void>parameter(nvidia::gxf::Parameter<T>&parameter,constParameterInfo<T>&parameter_info,)#Registers a parameter withParameterInfocontaining all the parameter metadata, where T is a valid parameter type.Parameters:parameter– The parameter to registerparameter_info– A struct containing all the parameter metadataReturns:Expected<void> Success or error code on failuretemplate<typenameT>Expected<void>registerParameterlessComponent()#Registers a component with no parameters. This is called internally by GXF ifregisterInterface()is not overridden.Returns:Expected<void> Success or error code on failurestaticconstexprUnexpectedNoDefaultParameter()#Returns a constant for registering an optional parameter with no default value.Returns:Unexpected with code GXF_PARAMETER_NOT_INITIALIZEDtemplate<typenameT>Expected<void>resource(Resource<Handle<T>>&resource,constchar*description,)#Registers a resource with a descriptionParameters:resource– The resource to registerdescription– A detailed description of the resourceReturns:Expected<void> Success or error code on failurepreviousGXF App Python APIsnextGXF Core C APIsOn this pageExpectedExpectedExpected()Expected()has_value()value()error()ForwardError()ForwardError()ToResultCode()ExpectedOrCode()ExpectedOrCode()ExpectedOrError()AccumulateError()AccumulateError()ComponentComponentinitialize()deinitialize()registerInterface()context()eid()cid()tid()type_name()entity()name()internalSetup()getParameter()wrapParameter()setParameter()setParameter()parseParameter()getParametersOfType()getParameterInfo()~Component()Component()Component()operator=()operator=()EntityEntityNew()Own()Shared()Entity()Entity()Entity()~Entity()context()eid()is_null()name()activate()deactivate()clone()add()add()get()get()findAll()findAll()findAllHeap()findAllHeap()remove()remove()remove()entity_item_ptr()HandleUntypedHandle ClassUntypedHandleNull()Create()context()cid()tid()is_null()operatorbool()name()UntypedHandle()UntypedHandle()operator=()operator=()Handle ClassHandleNull()Unspecified()Create()Create()operator==()operator!=()operator<()Handle()operatorT*()operator->()get()try_get()Handle()Handle()operator=()operator=()ParametersParameterParameter()Parameter()get()operatorconstT&()try_get()set()connect()key()set_without_propagate()Parameter TypesParameterParserParse()ParameterWrapperWrap()Parameter RegistrationRegistrarparameter()parameter()parameter()parameter()parameter()parameter()parameter()registerParameterlessComponent()NoDefaultParameter()resource()Privacy Policy|Manage My Privacy|Do Not Sell or Share My Data|Terms of Service|Accessibility|Corporate Policies|Product Security|ContactCopyright © 2024-2025, NVIDIA Corporation.Last updated on Jan 13, 2025.