GXF Component Interfaces — DeepStream documentationSkip to main contentBack to topCtrl+KDeepStream documentationDeepStream documentationTable of ContentsDeepStream Getting StartedWelcome to the DeepStream DocumentationMigration GuideInstallationQuickstart GuideDocker ContainersDeepStream SamplesC/C++ Sample Apps Source DetailsPython Sample Apps and Bindings Source DetailsDeepStream Reference Application - deepstream-appDeepStream Reference Application - deepstream-test5 appDeepStream Reference Application - deepstream-nmos appDeepStream Reference Application on GitHubSample Configurations and StreamsImplementing a Custom GStreamer Plugin with OpenCV Integration ExampleTAO toolkit Integration with DeepStreamTAO Toolkit Integration with DeepStreamTutorials and How-to'sDeepStream-3D Custom Apps and Libs TutorialsDeepStream PerformancePerformanceDeepStream AccuracyAccuracy Tuning ToolsDeepStream Custom ModelUsing a Custom Model with DeepStreamDeepStream Key FeaturesDeepStream-3D Sensor Fusion Multi-Modal Application and FrameworkDeepStream-3D Multi-Modal BEVFusion SetupDeepStream-3D Multi-Modal V2XFusion SetupSmart Video RecordIoTOn the Fly Model UpdateNTP Timestamp in DeepStreamAV Sync in DeepStreamDeepStream With REST API SeverDeepStream 3D Action Recognition AppDeepStream 3D Depth Camera AppDeepStream 3D Lidar Inference AppNetworked Media Open Specifications (NMOS) in DeepStreamGst-nvdspostprocess in DeepStreamDeepStream Can Orientation AppDeepStream Application MigrationApplication Migration to DeepStream 7.1 from DeepStream 7.0DeepStream Plugin GuideGStreamer Plugin OverviewMetaData in the DeepStream SDKGst-nvdspreprocess (Alpha)Gst-nvinferGst-nvinferserverGst-nvtrackerGst-nvstreammuxGst-nvstreammux NewGst-nvstreamdemuxGst-nvmultistreamtilerGst-nvdsosdGst-nvdsmetautilsGst-nvdsvideotemplateGst-nvdsaudiotemplateGst-nvvideoconvertGst-nvdewarperGst-nvofGst-nvofvisualGst-nvsegvisualGst-nvvideo4linux2Gst-nvjpegdecGst-nvimagedecGst-nvjpegencGst-nvimageencGst-nvmsgconvGst-nvmsgbrokerGst-nvdsanalyticsGst-nvdsudpsrcGst-nvdsudpsinkGst-nvdspostprocess (Alpha)Gst-nvds3dfilterGst-nvds3dbridgeGst-nvds3dmixerGst-NvDsUcxGst-nvdsxferGst-nvvideotestsrcGst-nvmultiurisrcbinGst-nvurisrcbinDeepStream Troubleshooting and FAQTroubleshootingFrequently Asked QuestionsDeepStream On WSL2DeepStream On WSLFAQ for Deepstream On WSLDeepStream API GuideDeepStream API GuidesDeepStream Service MakerWhat is Deepstream Service MakerService Maker for C/C++ DevelopersService Maker for Python Developers(alpha)Quick Start GuideIntroduction to Flow APIsIntroduction to Pipeline APIsAdvanced FeaturesMigrating Traditional Deepstream Apps to Service Maker Apps in PythonWhat is a Deepstream Service Maker PluginDeepstream LibrariesDeepStream Libraries (Developer Preview)Graph ComposerOverviewPlatformsSupported platformsGetting StartedApplication Development WorkflowCreating an AI ApplicationReference graphsExtension Development WorkflowDeveloping Extensions for DeepStreamDeepStream ComponentsGXF InternalsGXF InternalsGraph eXecution EngineGraph Execution EngineGraph Composer ContainersGraph Composer and GXF ContainersGXF Component InterfacesGXF Component InterfacesGXF Application API'sGXF App C++ APIsGXF App Python APIsGXF Runtime API'sGXF Core C++ APIsGXF Core C APIsGXF Core Python APIsExtension ManualExtensionsCudaExtensionGXF Stream SyncStandardExtensionPython CodeletsNetworkExtensionNvTritonExtSerializationExtensionMultimediaExtensionVideoEncoderExtensionVideoDecoderExtensionBehavior TreesUCX ExtensionHttpExtensionGrpcExtensionTensorRTExtensionNvDs3dProcessingExtNvDsActionRecognitionExtNvDsAnalyticsExtNvDsBaseExtNvDsCloudMsgExtNvDsConverterExtNvDsDewarperExtNvDsInferenceExtNvDsInferenceUtilsExtNvDsInterfaceExtNvDsMuxDemuxExtNvDsOpticalFlowExtNvDsOutputSinkExtNvDsSampleExtNvDsSampleModelsExtNvDsSourceExtNvDsTemplateExtNvDsTrackerExtNvDsTranscodeExtNvDsTritonExtNvDsUcxExtNvDsUdpExtNvDsVisualizationExtToolsRegistryRegistry Command Line InterfaceComposerContainer BuilderGXF Command Line InterfacePipetuner GuideFAQ GuideFAQDeepStream Legal InformationDeepStream End User License AgreementDeepStream FeedbackFeedback formGXF...GXF Component Interfaces#Codelet#classnvidia::gxf::Codelet#Codelets are special components which allow the execution of custom code. The user can
create her own codelets by deriving from this class and overriding the functionsinitialize(),start(),tick(),stop(), anddeinitialize().virtual~Codelet()=default#Destructor.virtualgxf_result_tstart()#This function is called during the start phase of the codelet. It allows derived classes to
execute custom code during the start phase. This is a good place to obtain resources which
are necessary for ticking the codelet. This function is guaranteed to be called before the
first call totick().Returns:GXF_SUCCESS if successful, an error code otherwise.virtualgxf_result_ttick()=0#This function is called whenever the codelet is expected to do work, e.g. when an event was
received or periodically. Thetick()method can be specified with various other member functions.
This function is the main work horse of the codelet.Returns:GXF_SUCCESS if successful, an error code otherwise.virtualgxf_result_tstop()#This function is called during the stop phase of the codelet. It allows derived classes to
execute custom code during the stop phase. This is a good place to clean up any resources which
where obtained during ‘start’. After the codelet is stopped it should be in the same state as
it was before ‘start’ was called. Be careful to not leave any unintended left overs as ‘start’
might be called again afterwards. It is guaranteed that stop is called after the last
call to tick. When start was called stop will be called, too.Returns:GXF_SUCCESS if successful, an error code otherwise.int64_tgetExecutionTimestamp()const#Timestamp (in nanoseconds) of the beginning of the start, tick or stop function. The execution
timestamp does not change during the start, tick or stop function.Returns:The execution timestamp in nanoseconds.doublegetExecutionTime()const#Similar togetExecutionTimestamp()but returns time as a floating point number and using seconds
as unit. Equivalent to ‘ToSeconds(getExecutionCount())’.Returns:The execution time in seconds.doublegetDeltaTime()const#The delta between the current execution time and the execution time of the previous execution.
During the start function this will return 0.Returns:The delta time in seconds.int64_tgetExecutionCount()const#Returns the number of times a codelet is executed. This will return 0 during start and 1 during
the first tick.Returns:The execution count.boolisFirstTick()const#Returns true if this is the first time tick is called after start.Returns:True if this is the first tick, false otherwise.voidbeforeStart(int64_ttimestamp)#Called by EntityExecutor before each ‘start’Parameters:timestamp– The current timestamp from the clock. Timestamps are measured in nanoseconds.voidbeforeTick(int64_ttimestamp)#Called by EntityExecutor before each ‘tick’
:param timestamp: The current timestamp from the clock. Timestamps are measured in nanoseconds.voidbeforeStop()#Called by EntityExecutor before each ‘stop’Allocator#enumnvidia::gxf::MemoryStorageType#Enum representing the type of memory storage.enumeratorMemoryStorageType::kHost#Page locked / Pinned memory allocated on the hostenumeratorMemoryStorageType::kDevice#Memory allocated on the device / GPUenumeratorMemoryStorageType::kSystem#Memory allocated on the Heapenumnvidia::gxf::AllocatorStage#Specifies the stage of the allocator.enumeratorAllocatorStage::kUninitialized#enumeratorAllocatorStage::kInitializationInProgress#enumeratorAllocatorStage::kInitialized#enumeratorAllocatorStage::kDeinitializationInProgress#classnvidia::gxf::Allocator#Provides allocation and deallocation of memory.virtual~Allocator()=default#Destructor.virtualgxf_result_tis_available_abi(uint64_tsize)=0#Returns whether the allocator can provide a memory block of the given size.Parameters:size– The size of the memory block.Returns:GXF_SUCCESS if the memory block can be provided, an error code otherwise.virtualgxf_result_tallocate_abi(uint64_tsize,int32_ttype,void**pointer,)=0#Allocates a memory block of the given size and type.Parameters:size– The size of the memory block.type– The type of memory to allocate.pointer– A pointer to the allocated memory block.Returns:GXF_SUCCESS if the memory block was allocated successfully, an error code otherwise.virtualgxf_result_tfree_abi(void*pointer)=0#Frees a previously allocated memory block.Parameters:pointer– A pointer to the memory block to be freed.Returns:GXF_SUCCESS if the memory block was freed successfully, an error code otherwise.virtualuint64_tblock_size_abi()const=0#Returns the block size of the allocator.Returns:The block size of the allocator.Expected<byte*>allocate(uint64_tsize,MemoryStorageTypetype)#Allocates a memory block of the given size and type.Parameters:size– The size of the memory block.type– The type of memory to allocate.Returns:Expected<byte*> pointer to the newly created memory or error code on failure.Expected<void>free(byte*pointer)#Frees a previously allocated memory block.Parameters:pointer– A pointer to the memory block to be freed.Returns:Expected<void> Success or error code on failureconstchar*allocator_stage_str(AllocatorStagestage)const#Returns the string value of the allocator stage.Parameters:stage– The allocator stage.Returns:The string value of the allocator stage.CudaAllocator#classnvidia::gxf::CudaAllocator:publicAllocator#Provides allocation and deallocation of memory with Stream order memory allocators.virtual~CudaAllocator()=default#Destructor.virtualExpected<byte*>allocate(uint64_tsize,cudaStream_tstream,)=0#Allocates a memory block of the specified size and type on the given CUDA stream.
It performs the allocation on the CUDA device asynchronously, meaning it does not synchronize
the CUDA stream following the allocation. This is used to allocate memory on device.Parameters:size– The size of the memory block.stream– Cuda stream which is used to allocate memory.Returns:Expected<byte*> pointer to the newly created memory or error code on failurevirtualExpected<void>free(void*pointer,cudaStream_tstream)=0#Frees a previously allocated memory block on given cuda stream asynchronously.Parameters:pointer– A pointer to the memory block to be freed.stream– The CUDA stream that requires memory deallocation.Returns:Expected<void> Success or error code on failuregxf_result_tallocate_async_abi(uint64_tsize,void**pointer,cudaStream_tstream,)#Allocates a memory block of the specified size and type on the given CUDA stream.Parameters:size– The size of the memory block.pointer– A pointer to the allocated memory block.stream– Cuda stream which on which memory is allocated.Returns:GXF_SUCCESS if the memory block was allocated successfully, an error code otherwise.gxf_result_tfree_async_abi(void*pointer,cudaStream_tstream)#Frees a previously allocated memory block on given cuda stream asynchronously.Parameters:pointer– A pointer to the memory block to be freed.stream– The CUDA stream that requires memory deallocation.Returns:GXF_SUCCESS if the memory block was allocated successfully, an error code otherwise.Expected<size_t>get_pool_size(MemoryStorageTypetype)const#Retrieve the current size of the memory pool for the specified type.Parameters:type– The memory type from which we derive the pool size.Returns:Expected<size_t> current memory pool size of specified type or error code on failure.Receiver#classnvidia::gxf::Receiver#Interface for receiving entities.virtualgxf_result_treceive_abi(gxf_uid_t*uid)=0#Receives the next entity from the main stage.Parameters:uid– The UID of the received entity.Returns:GXF_SUCCESS if successful, an error code otherwise.virtualsize_tback_size_abi()=0#The total number of entities which have recently arrived but are not yet on the main stage.Returns:The number of entities in the back stage.virtualgxf_result_tpeek_back_abi(gxf_uid_t*uid,int32_tindex)=0#Peeks into back stage at a specific index.Parameters:uid– The UID of the entity at the index.index– The index of the entity to peek.Returns:GXF_SUCCESS if successful, an error code otherwise.virtualgxf_result_tsync_abi()=0#Moves entities which recently arrived to the main stage.Returns:GXF_SUCCESS if successful, an error code otherwise.virtualgxf_result_tsync_io_abi()#Syncs I/O.Returns:GXF_SUCCESS if successful, an error code otherwise.virtualgxf_result_twait_abi()#Waits for entities to arrive.Returns:GXF_SUCCESS if successful, an error code otherwise.Expected<Entity>receive()#Receives the next entity from the main stage.Returns:The received entity.size_tback_size()#The total number of entities which have recently arrived but are not yet on the main stage.Returns:The number of entities in the back stage.Expected<void>sync()#Moves entities which recently arrived to the main stage.Returns:Expected<void> Success or error code on failureExpected<void>sync_io()#Sync I/O.Returns:Expected<void> Success or error code on failureExpected<void>wait()#Wait for entities to arrive.Returns:Expected<void> Success or error code on failureExpected<Entity>peekBack(int32_tindex=0)#Peeks into back stage at a specific index.Parameters:index– The index of the entity to peek.Returns:The peeked entity.Expected<void>setTransmitter(Handle<Transmitter>tx)#Sets the transmitter to form a connectionParameters:tx– Handle to a transmitter to connect to.Returns:Expected<void> Success or error code on failureTransmitter#classnvidia::gxf::Transmitter#Interface for publishing entities.virtualgxf_result_tpublish_abi(gxf_uid_tuid)=0#Publishes the entity with the given UID.Parameters:uid– The UID of the entity to publish.Returns:GXF_SUCCESS if successful, an error code otherwise.virtualsize_tback_size_abi()=0#The total number of entities which have previously been published and were moved out of the main stage.Returns:The number of entities in the back stage.virtualgxf_result_tsync_abi()=0#Moves entities which have been published to the main stage.Returns:GXF_SUCCESS if successful, an error code otherwise.virtualgxf_result_tsync_io_abi()#Sync I/O.Returns:GXF_SUCCESS if successful, an error code otherwise.virtualgxf_result_tpop_io_abi(gxf_uid_t*uid)#Pops the next entity.Parameters:uid– The UID of the popped entity.Returns:GXF_SUCCESS if successful, an error code otherwise.Expected<void>publish(constEntity&other)#Publishes the given entity.Parameters:other– The entity to publish.Returns:Expected<void> Success or error code on failureExpected<void>publish(Entity&other,constint64_tacq_timestamp)#Publishes the given entity with the specified acquisition timestamp.Parameters:other– The entity to publish.acq_timestamp– The acquisition timestamp of the entity.Returns:Expected<void> Success or error code on failuresize_tback_size()#The total number of entities which have been published but are not yet on the main stage.Returns:The number of entities in the back stage.Expected<void>sync()#Moves entities which have been published to the main stage.Returns:Expected<void> Success or error code on failureExpected<void>sync_io()#Syncs I/O.Returns:Expected<void> Success or error code on failureExpected<void>pop_io()#Pops the next entity.Returns:Expected<void> Success or error code on failureExpected<Entity>pop()#Pops the next entity.Returns:The popped entity.System#classnvidia::gxf::System#Component interface for systems which are run as part of the application run cycle.virtualgxf_result_tschedule_abi(gxf_uid_teid)=0#Schedules the entity with the given UID.Parameters:eid– The UID of the entity to schedule.Returns:GXF_SUCCESS if successful, an error code otherwise.virtualgxf_result_tunschedule_abi(gxf_uid_teid)=0#Unschedules the entity with the given UID.Parameters:eid– The UID of the entity to unschedule.Returns:GXF_SUCCESS if successful, an error code otherwise.virtualgxf_result_trunAsync_abi()=0#Runs the system asynchronously.Returns:GXF_SUCCESS if successful, an error code otherwise.virtualgxf_result_tstop_abi()=0#Stops the system.Returns:GXF_SUCCESS if successful, an error code otherwise.virtualgxf_result_twait_abi()=0#Waits for the system to complete execution.Returns:GXF_SUCCESS if successful, an error code otherwise.Expected<void>event_notify_abi(gxf_uid_teid,gxf_event_tevent)#Notifies the system of an event.Parameters:eid– The UID of the entity associated with the event.event– The event to notify the system of.Returns:Expected<void> Success or error code on failureExpected<void>schedule(constEntity&entity)#Schedules the given entity.Parameters:entity– The entity to schedule.Returns:Expected<void> Success or error code on failureExpected<void>unschedule(constEntity&entity)#Unschedules the given entity.Parameters:entity– The entity to unschedule.Returns:Expected<void> Success or error code on failureExpected<void>runAsync()#Runs the system asynchronously.Returns:Expected<void> Success or error code on failureExpected<void>stop()#Stops the system.Returns:Expected<void> Success or error code on failureExpected<void>wait()#Waits for the system to complete.Returns:Expected<void> Success or error code on failureExpected<void>event_notify(gxf_uid_teid,gxf_event_tevent)#Notifies the system of an event.Parameters:eid– The UID of the entity associated with the event.event– The event to notify the system of.Returns:Expected<void> Success or error code on failureScheduler#classnvidia::gxf::Scheduler:publicSystem#An interface which extends thenvidia::gxf::Systeminterface to create schedulers which can execute codelets.virtualgxf_result_tprepare_abi(EntityExecutor*executor)=0#Prepares the scheduler for execution by providing access to the entity executorParameters:executor– The entity executor to prepare for.Returns:GXF_SUCCESS if successful, an error code otherwise.SchedulingTerm#classnvidia::gxf::SchedulingTerm#Base class for scheduling terms. Scheduling terms are used by a scheduler to determine if codelets in an entity are ready for execution.virtual~SchedulingTerm()=default#Destructor.virtualgxf_result_tcheck_abi(int64_ttimestamp,SchedulingConditionType*type,int64_t*target_timestamp,)const=0#Get the condition on which the scheduling waits before allowing execution. If the term is waiting for a time event, target_timestamp will contain the target timestamp.Parameters:timestamp– The current timestamp.type– A pointer to a variable that will contain the scheduling condition type.target_timestamp– A pointer to a variable that will contain the target timestamp if the scheduling condition is waiting for a time event.Returns:GXF_SUCCESS if the function was executed successfully, an error code otherwise.virtualgxf_result_tonExecute_abi(int64_tdt)=0#Called each time after the entity of this term was executed.Parameters:dt– The current timestamp.Returns:GXF_SUCCESS if the function was executed successfully, an error code otherwise.virtualgxf_result_tupdate_state_abi(int64_ttimestamp)#Checks if the state of the scheduling term can be updated and updates it.Parameters:timestamp– The current timestamp.Returns:GXF_SUCCESS if the function was executed successfully, an error code otherwise.Expected<SchedulingCondition>check(int64_ttimestamp)#Checks the scheduling condition and returns the result.Parameters:timestamp– The current timestamp.Returns:An expected scheduling condition if the function was executed successfully, an unexpected error otherwise.Expected<void>onExecute(int64_ttimestamp)#Called each time after the entity of this term was executed.Parameters:timestamp– The current timestamp.Returns:Expected<void> Success or error code on failureRouter#classnvidia::gxf::Router#A base class for objects which are routing messages in and out of entities.virtualExpected<void>addRoutes(constEntity&entity)=0#Notifies the router about a new entity. This function is called when a new entity is added to the system.
The router uses this function to set up any necessary routing for the entity’s inbox and outbox.Parameters:entity– The entity to add routes for.Returns:Expected<void> Success or error code on failurevirtualExpected<void>removeRoutes(constEntity&entity)=0#Notifies the router about the removal of an entity. This function is called when an entity is removed from the system.
The router uses this function to clean up any routing that was set up for the entity’s inbox and outbox.Parameters:entity– The entity to remove routes for.Returns:Expected<void> Success or error code on failurevirtualExpected<void>syncInbox(constEntity&entity)=0#Synchronizes the inbox of an entity and prepares it for execution. This function is called when an entity is scheduled for execution.
The router uses this function to synchronize the entity’s inbox, ensuring that any new messages are available for processing.Parameters:entity– The entity to synchronize the inbox for.Returns:Expected<void> Success or error code on failurevirtualExpected<void>wait(constEntity&entity)#This function causes the router to wait until the entity’s inbox has new messages.Parameters:entity– The entity to wait for.Returns:Expected<void> Success or error code on failurevirtualExpected<void>syncOutbox(constEntity&entity)=0#Synchronizes the outbox of an entity after successful executionParameters:entity– The entity to synchronize the outbox for.Returns:Expected<void> Success or error code on failurevirtualExpected<void>setClock(Handle<Clock>clock)=0#Sets the clock to be used to for updating the pubtime while publishing messagesParameters:clock– The clock to set.Returns:Expected<void> Success or error code on failurevirtualExpected<void>addNetworkContext(Handle<NetworkContext>context,)=0#Sets the network context to be used by network routerParameters:context– The network context to set.Returns:Expected<void> Success or error code on failureClock#classnvidia::gxf::Clock#A class for keeping track of timevirtualdoubletime()const=0#The current time of the clock. Time is measured in seconds.Returns:The current time in seconds.virtualint64_ttimestamp()const=0#The current timestamp of the clock. Timestamps are measured in nanoseconds.Returns:The current timestamp in nanoseconds.virtualExpected<void>sleepFor(int64_tduration_ns)=0#Waits until the given duration has elapsed on the clockParameters:duration_ns– sleep duration in nanosecondsReturns:Expected<void> Success or error code on failurevirtualExpected<void>sleepUntil(int64_ttarget_ns)=0#Waits until the given target time has elapsed on the clockParameters:target_ns– target time duration to wait until in nanosecondsReturns:Expected<void> Success or error code on failureBenchmark#BenchmarkController#classnvidia::gxf::benchmark::BenchmarkController#A benchmark controller that governs the entire benchmark flowBenchmarkPublisher#classnvidia::gxf::benchmark::BenchmarkPublisher#A benchmark publisher that publishes buffered benchmark messagesgxf::Handle<EntityBuffer>getEntityBuffer()#Getter of the underlying entity buffer componentReturns:gxf::Handle<EntityBuffer> Valid handle or error code on failurestd::vector<std::chrono::nanoseconds>&getPublishedTimestamps();#Getter of the recorded published timestampsReturns:std::vector<std::chrono::nanoseconds> Vector of published timestampsgxf::Handle<gxf::AsynchronousSchedulingTerm>getAsyncSchedulingterm();#Getter of the associated async scheduling termReturns:gxf::Handle<gxf::AsynchronousSchedulingTerm> Valid handle or error code on failurevoidsetNumOfMessagesToPublish(uint64_tnum_of_messages_to_publish);#Setter of the number of benchmark messages to publishParameters:num_of_messages_to_publish– No of messages to publish. 0 means no limitvoidclearRecordedTimestamps();#Clear the runtime state. Calling this fucntion is sufficient to reset state for a new benchmark iterationBenchmarkSink#classnvidia::gxf::benchmark::BenchmarkSink#A benchmark sink that records message arrival timestampsgxf::Expected<void>begin()override;#Signal the start of a benchmark iterationReturn:gxf::Expected<void>end()override;#Signal the end of a benchmark iterationReturn:gxf::Expected<void>reset()override;#Reset states of the benchmark sink and the associated perf calculatorsReturn:gxf::Expected<nlohmann::json>compute()override;#Compute performance outcome for the recorded timestamps.
The results are expected to be buffered in the associated perf calculators.Return:nlohmann::jsonconclude()override;#Conclude the performance results from the associated perf calculatorsReturn:std::vector<std::chrono::nanoseconds>&getReceivedTimestamps()override;#Getter of the recorded received timestampsReturn:gxf::Expected<std::vector<gxf::Handle<PerformanceCalculatorBase>>>getPerformanceCalculators()override;#Getter of the associated performance calculator component handlesReturn:gxf::Expected<std::vector<gxf::Handle<PerformanceCalculatorBase>>>voidclearRecordedTimestamps()override;#Clear the runtime state
Calling this fucntion is sufficient to reset state for a new benchmark iterationpreviousGraph Composer and GXF ContainersnextGXF App C++ APIsOn this pageCodeletCodelet~Codelet()start()tick()stop()getExecutionTimestamp()getExecutionTime()getDeltaTime()getExecutionCount()isFirstTick()beforeStart()beforeTick()beforeStop()AllocatorMemoryStorageTypekHostkDevicekSystemAllocatorStagekUninitializedkInitializationInProgresskInitializedkDeinitializationInProgressAllocator~Allocator()is_available_abi()allocate_abi()free_abi()block_size_abi()allocate()free()allocator_stage_str()CudaAllocatorCudaAllocator~CudaAllocator()allocate()free()allocate_async_abi()free_async_abi()get_pool_size()ReceiverReceiverreceive_abi()back_size_abi()peek_back_abi()sync_abi()sync_io_abi()wait_abi()receive()back_size()sync()sync_io()wait()peekBack()setTransmitter()TransmitterTransmitterpublish_abi()back_size_abi()sync_abi()sync_io_abi()pop_io_abi()publish()publish()back_size()sync()sync_io()pop_io()pop()SystemSystemschedule_abi()unschedule_abi()runAsync_abi()stop_abi()wait_abi()event_notify_abi()schedule()unschedule()runAsync()stop()wait()event_notify()SchedulerSchedulerprepare_abi()SchedulingTermSchedulingTerm~SchedulingTerm()check_abi()onExecute_abi()update_state_abi()check()onExecute()RouterRouteraddRoutes()removeRoutes()syncInbox()wait()syncOutbox()setClock()addNetworkContext()ClockClocktime()timestamp()sleepFor()sleepUntil()BenchmarkBenchmarkControllerBenchmarkControllerBenchmarkPublisherBenchmarkPublishergetEntityBuffer()getPublishedTimestamps()getAsyncSchedulingterm()setNumOfMessagesToPublish()clearRecordedTimestamps()BenchmarkSinkBenchmarkSinkbegin()end()reset()compute()conclude()getReceivedTimestamps()getPerformanceCalculators()clearRecordedTimestamps()Privacy Policy|Manage My Privacy|Do Not Sell or Share My Data|Terms of Service|Accessibility|Corporate Policies|Product Security|ContactCopyright © 2024-2025, NVIDIA Corporation.Last updated on Jan 13, 2025.