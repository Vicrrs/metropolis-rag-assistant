DeepStream Reference Application - deepstream-test5 app — DeepStream documentationSkip to main contentBack to topCtrl+KDeepStream documentationDeepStream documentationTable of ContentsDeepStream Getting StartedWelcome to the DeepStream DocumentationMigration GuideInstallationQuickstart GuideDocker ContainersDeepStream SamplesC/C++ Sample Apps Source DetailsPython Sample Apps and Bindings Source DetailsDeepStream Reference Application - deepstream-appDeepStream Reference Application - deepstream-test5 appDeepStream Reference Application - deepstream-nmos appDeepStream Reference Application on GitHubSample Configurations and StreamsImplementing a Custom GStreamer Plugin with OpenCV Integration ExampleTAO toolkit Integration with DeepStreamTAO Toolkit Integration with DeepStreamTutorials and How-to'sDeepStream-3D Custom Apps and Libs TutorialsDeepStream PerformancePerformanceDeepStream AccuracyAccuracy Tuning ToolsDeepStream Custom ModelUsing a Custom Model with DeepStreamDeepStream Key FeaturesDeepStream-3D Sensor Fusion Multi-Modal Application and FrameworkDeepStream-3D Multi-Modal BEVFusion SetupDeepStream-3D Multi-Modal V2XFusion SetupSmart Video RecordIoTOn the Fly Model UpdateNTP Timestamp in DeepStreamAV Sync in DeepStreamDeepStream With REST API SeverDeepStream 3D Action Recognition AppDeepStream 3D Depth Camera AppDeepStream 3D Lidar Inference AppNetworked Media Open Specifications (NMOS) in DeepStreamGst-nvdspostprocess in DeepStreamDeepStream Can Orientation AppDeepStream Application MigrationApplication Migration to DeepStream 7.1 from DeepStream 7.0DeepStream Plugin GuideGStreamer Plugin OverviewMetaData in the DeepStream SDKGst-nvdspreprocess (Alpha)Gst-nvinferGst-nvinferserverGst-nvtrackerGst-nvstreammuxGst-nvstreammux NewGst-nvstreamdemuxGst-nvmultistreamtilerGst-nvdsosdGst-nvdsmetautilsGst-nvdsvideotemplateGst-nvdsaudiotemplateGst-nvvideoconvertGst-nvdewarperGst-nvofGst-nvofvisualGst-nvsegvisualGst-nvvideo4linux2Gst-nvjpegdecGst-nvimagedecGst-nvjpegencGst-nvimageencGst-nvmsgconvGst-nvmsgbrokerGst-nvdsanalyticsGst-nvdsudpsrcGst-nvdsudpsinkGst-nvdspostprocess (Alpha)Gst-nvds3dfilterGst-nvds3dbridgeGst-nvds3dmixerGst-NvDsUcxGst-nvdsxferGst-nvvideotestsrcGst-nvmultiurisrcbinGst-nvurisrcbinDeepStream Troubleshooting and FAQTroubleshootingFrequently Asked QuestionsDeepStream On WSL2DeepStream On WSLFAQ for Deepstream On WSLDeepStream API GuideDeepStream API GuidesDeepStream Service MakerWhat is Deepstream Service MakerService Maker for C/C++ DevelopersService Maker for Python Developers(alpha)Quick Start GuideIntroduction to Flow APIsIntroduction to Pipeline APIsAdvanced FeaturesMigrating Traditional Deepstream Apps to Service Maker Apps in PythonWhat is a Deepstream Service Maker PluginDeepstream LibrariesDeepStream Libraries (Developer Preview)Graph ComposerOverviewPlatformsSupported platformsGetting StartedApplication Development WorkflowCreating an AI ApplicationReference graphsExtension Development WorkflowDeveloping Extensions for DeepStreamDeepStream ComponentsGXF InternalsGXF InternalsGraph eXecution EngineGraph Execution EngineGraph Composer ContainersGraph Composer and GXF ContainersGXF Component InterfacesGXF Component InterfacesGXF Application API'sGXF App C++ APIsGXF App Python APIsGXF Runtime API'sGXF Core C++ APIsGXF Core C APIsGXF Core Python APIsExtension ManualExtensionsCudaExtensionGXF Stream SyncStandardExtensionPython CodeletsNetworkExtensionNvTritonExtSerializationExtensionMultimediaExtensionVideoEncoderExtensionVideoDecoderExtensionBehavior TreesUCX ExtensionHttpExtensionGrpcExtensionTensorRTExtensionNvDs3dProcessingExtNvDsActionRecognitionExtNvDsAnalyticsExtNvDsBaseExtNvDsCloudMsgExtNvDsConverterExtNvDsDewarperExtNvDsInferenceExtNvDsInferenceUtilsExtNvDsInterfaceExtNvDsMuxDemuxExtNvDsOpticalFlowExtNvDsOutputSinkExtNvDsSampleExtNvDsSampleModelsExtNvDsSourceExtNvDsTemplateExtNvDsTrackerExtNvDsTranscodeExtNvDsTritonExtNvDsUcxExtNvDsUdpExtNvDsVisualizationExtToolsRegistryRegistry Command Line InterfaceComposerContainer BuilderGXF Command Line InterfacePipetuner GuideFAQ GuideFAQDeepStream Legal InformationDeepStream End User License AgreementDeepStream FeedbackFeedback formDeepStream...DeepStream Reference Application - deepstream-test5 app#Test5 application, in addition to regular inference pipeline, supports the following features:Sending the messages to back end server.Working as consumer to receive messages from the back-end server.Triggering event-based recording based on the messages received from the server.OTA model update.Sensor Provisioning Support over REST APIIoT Protocols supported and cloud configuration#Details on the IoT Protocols (like KAFKA, Azure, AMQP, etc.,) supported bynvmsgbrokerplugin is listed in the DeepStream Plugin guide.
DeepStream Public documentation may be referred to setup IoT hubs/servers/brokers specific to the protocol in use.
[sink] group keys associated withtype=6fornvmsgconvandnvmsgbrokerconfiguration are discussed in theConfiguration Groups.Message consumer#deepstream-test5-appcan be configured to work as message consumer for cloud messages. After parsing the received message, based on the content of the message specific action(s) can be triggered.
For example,NvDsSrcParentBin*, which holds the smart record context, is passed as an argument instart_cloud_to_device_messaging()which is used to trigger start/stop of smart record.
By default, event-based recording has been implemented to demonstrate the usage of message consumer. User need to implement the custom logic to work on other types of received messages.
Seedeepstream_c2d_msg*files for more details about implementation.
To subscribe to cloud messages, configure the[message-consumer]group(s) accordingly.Smart Record - Event based recording#Test5 application can be configured to record the original video feed based on the event received from the server. In this way, instead of saving data all the time, this feature allows to record only event of interests.
Refer to the DeepStream plugin manual andgst-nvdssr.h``headerfileformoredetailsaboutsmartrecord.Eventbasedrecordingcanbeenabledbysetting``smart-recordunder[sourceX]group. Currently test5 app only supports source type = 4 (RTSP). Similar approach can be used for other types of sources as well.
There are two ways in which smart record events can be triggered:Through cloud messages.To trigger smart record through cloud messages, Test5 app should be configured to work as a message consumer. This can be done by configuring [message-consumerX] group(s) accordingly.After configuring the message consumer, smart record should be enabled on the source(s) on which event-based recording is desired. This can be done as follows:smart-record=1Following minimum Json message is expected to trigger the start / stop of smart record.{command:string// <start-recording / stop-recording>start:string// "2020-05-18T20:02:00.051Z"end:string// "2020-05-18T20:02:02.851Z",sensor:{id:string}}Through local events.Setsmart-record=2, this will enable smart record through cloud messages as well as local events.
To demonstrate the event-based recording through local events, application by default triggers start / stop events every ten seconds. This interval and other parameters are configurable.OTA model update#Test5 app can update the models in the running pipeline on-the-fly. For this, the app provides the command line option-o. If test5 app is launched with-o(ota_override_file) option, any change to that file is monitored and based on the change in that file, running pipeline is updated with the new models on-the-fly.Using the OTA functionality#Perform the following to use the OTA functionality:Rundeepstream-test5-appwith-o<ota_override_file>optionWhile DS application is running, update the<ota_override_file>with new model details and save itFile content changes gets detected bydeepstream-test5-appand then it starts model-update process. Currently only model-update feature is supported as a part of OTA functionality.Assumption for On-The-Fly model updates:New model must have same network parameter configuration as of previous model (e.g. network resolution, network architecture, number of classes)Engine file or cache file of new model to be provided by developerUpdated values for otherprimarygieconfiguration parameters likegroup-threshold,bboxcolor,gpu-id,nvbuf-memory-type, etc., if provided in the override file, will not have any effect after model switch.Secondarygiemodel-update is not validated, only primary model-update is validated.No frame drop / frames without inference should be observed during on-the-fly model update processIn case of model update failure, error message will be printed on the console and pipeline should continue to run with older model configurationconfig-fileparameter is needed to suppress the config file parsing error prints, values from this config file are not used during model switch processSensor Provisioning Support over REST API (Runtime sensor add/remove capability)#By enabling the use of nvmultiurisrcbin, deepstream-(test5-)app can support runtime sensor ADD/REMOVE capability.More information on nvmultiurisrcbin can be foundhere.Sample command to run deepstream-test5-app with nvmultiurisrcbin:cd/opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-test5/configsdeepstream-test5-app-ctest5_config_file_nvmultiurisrcbin_src_list_attr_all.txtThe config file passed in the above command uses [source-list] config group with config key use-nvmultiurisrcbin=1 to employ nvmultiurisrcbin.App starts with 2 X sourcesAble to add/remove streams using the curl command REST API commands documented in SectionREST API payload definitions and sample curl commands for reference.By default the nvstreammux config key drop-pipeline-eos is set, allowing the app to always be alive. This means the application will not quit even after the last stream EOS. This allows the running REST Server to provision additional sensors.By default stream name is not observed in FPS logs. In source-list group, set stream-name-display=1 to view stream names along with source-id.By default on stream addition the tiler will not reutilize the empty tiles. Set square-seq-grid=1 to always follow a square grid and empty tiles will be reused if a new source is added.previousDeepStream Reference Application - deepstream-appnextDeepStream Reference Application - deepstream-nmos appOn this pageIoT Protocols supported and cloud configurationMessage consumerSmart Record - Event based recordingOTA model updateUsing the OTA functionalitySensor Provisioning Support over REST API (Runtime sensor add/remove capability)Privacy Policy|Manage My Privacy|Do Not Sell or Share My Data|Terms of Service|Accessibility|Corporate Policies|Product Security|ContactCopyright © 2024-2025, NVIDIA Corporation.Last updated on Jan 13, 2025.