Gst-nvtracker — DeepStream documentationSkip to main contentBack to topCtrl+KDeepStream documentationDeepStream documentationTable of ContentsDeepStream Getting StartedWelcome to the DeepStream DocumentationMigration GuideInstallationQuickstart GuideDocker ContainersDeepStream SamplesC/C++ Sample Apps Source DetailsPython Sample Apps and Bindings Source DetailsDeepStream Reference Application - deepstream-appDeepStream Reference Application - deepstream-test5 appDeepStream Reference Application - deepstream-nmos appDeepStream Reference Application on GitHubSample Configurations and StreamsImplementing a Custom GStreamer Plugin with OpenCV Integration ExampleTAO toolkit Integration with DeepStreamTAO Toolkit Integration with DeepStreamTutorials and How-to'sDeepStream-3D Custom Apps and Libs TutorialsDeepStream PerformancePerformanceDeepStream AccuracyAccuracy Tuning ToolsDeepStream Custom ModelUsing a Custom Model with DeepStreamDeepStream Key FeaturesDeepStream-3D Sensor Fusion Multi-Modal Application and FrameworkDeepStream-3D Multi-Modal BEVFusion SetupDeepStream-3D Multi-Modal V2XFusion SetupSmart Video RecordIoTOn the Fly Model UpdateNTP Timestamp in DeepStreamAV Sync in DeepStreamDeepStream With REST API SeverDeepStream 3D Action Recognition AppDeepStream 3D Depth Camera AppDeepStream 3D Lidar Inference AppNetworked Media Open Specifications (NMOS) in DeepStreamGst-nvdspostprocess in DeepStreamDeepStream Can Orientation AppDeepStream Application MigrationApplication Migration to DeepStream 7.1 from DeepStream 7.0DeepStream Plugin GuideGStreamer Plugin OverviewMetaData in the DeepStream SDKGst-nvdspreprocess (Alpha)Gst-nvinferGst-nvinferserverGst-nvtrackerGst-nvstreammuxGst-nvstreammux NewGst-nvstreamdemuxGst-nvmultistreamtilerGst-nvdsosdGst-nvdsmetautilsGst-nvdsvideotemplateGst-nvdsaudiotemplateGst-nvvideoconvertGst-nvdewarperGst-nvofGst-nvofvisualGst-nvsegvisualGst-nvvideo4linux2Gst-nvjpegdecGst-nvimagedecGst-nvjpegencGst-nvimageencGst-nvmsgconvGst-nvmsgbrokerGst-nvdsanalyticsGst-nvdsudpsrcGst-nvdsudpsinkGst-nvdspostprocess (Alpha)Gst-nvds3dfilterGst-nvds3dbridgeGst-nvds3dmixerGst-NvDsUcxGst-nvdsxferGst-nvvideotestsrcGst-nvmultiurisrcbinGst-nvurisrcbinDeepStream Troubleshooting and FAQTroubleshootingFrequently Asked QuestionsDeepStream On WSL2DeepStream On WSLFAQ for Deepstream On WSLDeepStream API GuideDeepStream API GuidesDeepStream Service MakerWhat is Deepstream Service MakerService Maker for C/C++ DevelopersService Maker for Python Developers(alpha)Quick Start GuideIntroduction to Flow APIsIntroduction to Pipeline APIsAdvanced FeaturesMigrating Traditional Deepstream Apps to Service Maker Apps in PythonWhat is a Deepstream Service Maker PluginDeepstream LibrariesDeepStream Libraries (Developer Preview)Graph ComposerOverviewPlatformsSupported platformsGetting StartedApplication Development WorkflowCreating an AI ApplicationReference graphsExtension Development WorkflowDeveloping Extensions for DeepStreamDeepStream ComponentsGXF InternalsGXF InternalsGraph eXecution EngineGraph Execution EngineGraph Composer ContainersGraph Composer and GXF ContainersGXF Component InterfacesGXF Component InterfacesGXF Application API'sGXF App C++ APIsGXF App Python APIsGXF Runtime API'sGXF Core C++ APIsGXF Core C APIsGXF Core Python APIsExtension ManualExtensionsCudaExtensionGXF Stream SyncStandardExtensionPython CodeletsNetworkExtensionNvTritonExtSerializationExtensionMultimediaExtensionVideoEncoderExtensionVideoDecoderExtensionBehavior TreesUCX ExtensionHttpExtensionGrpcExtensionTensorRTExtensionNvDs3dProcessingExtNvDsActionRecognitionExtNvDsAnalyticsExtNvDsBaseExtNvDsCloudMsgExtNvDsConverterExtNvDsDewarperExtNvDsInferenceExtNvDsInferenceUtilsExtNvDsInterfaceExtNvDsMuxDemuxExtNvDsOpticalFlowExtNvDsOutputSinkExtNvDsSampleExtNvDsSampleModelsExtNvDsSourceExtNvDsTemplateExtNvDsTrackerExtNvDsTranscodeExtNvDsTritonExtNvDsUcxExtNvDsUdpExtNvDsVisualizationExtToolsRegistryRegistry Command Line InterfaceComposerContainer BuilderGXF Command Line InterfacePipetuner GuideFAQ GuideFAQDeepStream Legal InformationDeepStream End User License AgreementDeepStream FeedbackFeedback formGStreamer Plugin OverviewGst-nvtrackerGst-nvtracker#The Gst-nvtracker plugin allows the DS pipeline to use a low-level tracker library to track the detected objects over time persistently with unique IDs. It supports any low-level library that implementsNvDsTrackerAPI, including the reference implementations provided by theNvMultiObjectTrackerlibrary: IOU, NvSORT, NvDeepSORT and NvDCF trackers. As part of this API, the plugin queries the low-level library for capabilities and requirements concerning the input format, memory type, and additional feature support. Based on these queries, the plugin then converts the input frame buffers into the format requested by the low-level tracker library. For example, the NvDeepSORT and NvDCF trackers use NV12 or RGBA, while IOU and NvSORT requires no video frame buffers at all.Based on the queries, the Gst-nvtracker plugin constructs the input data to the low-level tracker library, which consists of video frames and detected objects across multiple streams that are fed to the low-level library in a single data structure (i.e, a frame batch) through a single API call. This API design allows all the input data from multiple streams in the low-level tracker library processed in a batched processing mode (similar to the batch mode incuFFT™,cuBLAS™, etc.) for potentially more efficient execution especially when accelerated on GPU. There for, it is required that the low-level tracker supportsbatch processingwhen usingNvMOT_ProcessAPI.The Gst-nvtracker plugin supports retrieval of the user-definedmiscellaneous datafrom the low-level tracker library throughNvMOT_RetrieveMiscDataAPI, which includes useful object tracking information other than the default data for the current frame targets; for example, past-frame object data, targets in shadow tracking mode, full trajectory of terminated targets and re-identification features. More details on the types of miscellaneous data and what they means can be found inMiscellaneous Data Outputsection. The users are allowed to define other types of miscellaneous data inNvMOTTrackerMiscData.More details on all these tracker APIs is discussed inNvDsTracker API for Low-Level Tracker Librarysection.The plugin accepts NV12- or RGBA-formatted frame data from the upstream component and scales (and/or converts) the input buffer to a buffer in the tracker plugin based on the format required by the low-level library, with the frame resolution specified bytracker-widthandtracker-heightin the configuration file’s[tracker]section. The path to the low-level tracker library is to be specified viall-lib-fileconfiguration option in the same section. The low-level library to be used may also require its own configuration file, which can be specified viall-config-fileoption. Ifll-config-fileis not specified, the low-level tracker library may proceed with its default parameter values.The reference low-level tracker implementations provided by theNvMultiObjectTrackerlibrary support various types of multi-object tracking algorithms:IOU Tracker: The Intersection-Over-Union (IOU) tracker uses the IOU values among the detector’s bounding boxes between the two consecutive frames to perform the association between them or assign a new target ID if no match found. This tracker includes a logic to handle false positives and false negatives from the object detector; however, this can be considered as the bare-minimum object tracker, which may serve as a baseline only.NvSORT: The NvSORT tracker is the NVIDIA®-enhanced Simple Online and Realtime Tracking (SORT) algorithm. Instead of a simple bipartite matching algorithm, NvSORT uses a cascaded data association based on bounding box (bbox) proximity for associating bboxes over consecutive frames and applies a Kalman filter to update the target states. It is computationally efficient since it does not involve any pixel data processing.NvDeepSORT: The NvDeepSORT tracker is the NVIDIA®-enhanced Online and Realtime Tracking with a Deep Association Metric (DeepSORT) algorithm, which uses the deep cosine metric learning with a Re-ID neural network for data association of multiple objects over frames. This implementation allows users to use any Re-ID network as long as it is supported by NVIDIA’s TensorRT™ framework. NvDeepSORT also uses a cascaded data association instead of a simple bipartite matching. The implementation is also optimized for efficient processing on GPU.NvDCF: The NvDCF tracker is an online multi-object tracker that employs a discriminative correlation filter for visual object tracking, which allows independent object tracking even when detection results are not available. It uses the combination of the correlation filter responses and bounding box proximity for data association.More details on each algorithm and its implementation details can be found inNvMultiObjectTracker : A Reference Low-Level Tracker Librarysection.NoteThe source code of the Gst-nvtracker plugin is provided as a part of DeepStream SDK package undersources/gst-plugins/gst-nvtracker/when installed on a system This is to allow users to make direct changes in the plugin whenever needed for their custom applications and also to show the users as to how the low-level libraries are managed and how the metadata is handled in the plugin.Sub-batching (Alpha)#The Gst-nvtracker plugin works in the batch processing mode by default. In this mode, the input frame batch is passed to and processed by asingleinstance of low-level tracker library. The advantage of batch processing mode is to allow GPUs to work on bigger amount of data at once, potentially increasing the GPU occupancy during execution and reducing the CUDA kernel launch overhead. Depending on the use cases, however, a potential issue is that there is a possibility that GPU could be idling (also referred to as GPU bubble) in some compute stages in the tracker unless the end-to-end operation within the module is carried out solely on the GPU. This is indeed the case if some of the compute modules in the tracker runs on CPU. If there are other components in the DeepStream pipeline that uses GPU (e.g., GPU-based inference in PGIE and SGIE), such CPU blocks in tracker can behiddenbehind them, not affecting the overall throughput of the pipeline.The newly-introducedSub-batchingfeature allows the plugin to split the input frame batch into multiple sub-batches (for example, a four-stream pipeline can use two sub-batches in the tracker plugin, each of which takes care of two streams). Each sub-batch is assigned to a separate instance of low-level tracker library, where the input to the corresponding sub-batch is processed separately. Each instance of low-level tracker libraries runs on a dedicated thread running independently, allowing parallel processing of sub-batches and minimizing the GPU idling due to CPU compute blocks, which eventually results in higher resource utilization.Because sub-batching assigns separate low-level tracker library instances to different sub-batches, it allows the user to configure each individual sub-batch differently with different low-level tracker library configuration files. This can be utilized in multiple ways like setting varied compute backends across sub-batches, using varied tracking algorithms across sub-batches or modifying any other configuration that is supported in low-level tracker configuration file. More detailed example use-cases are discussed inSetup and Usage of Sub-batching (Alpha)section.Inputs and Outputs#This section summarizes the inputs, outputs, and communication facilities of the Gst-nvtracker plugin.InputGst BufferA frame batch from available source streamsNvDsBatchMetaIncludes the detected object info from primary inference moduleMore details aboutNvDsBatchMetacan be found in the link.The color formats supported for the input video frame by the NvTracker plugin are NV12 and RGBA. A separate batch of video frames are created from the input video frames based on the color format and the resolution that is required to the low-level tracker library.OutputGst BufferSame as the input. Unmodified.NvDsBatchMetaUpdated with additional data from tracker low-level libraryThere’s no separate data structure for the output. Instead, the tracker plugin just adds/updates the data in the existingNvDsBatchMeta(and itsNvDsObjectMeta) with the output data from the tracker low-level library, including tracked object coordinates, tracker confidence, and object IDs. There are some other miscellaneous data that can be attached as user-meta, which is covered inMiscellaneous Data Outputsection.NoteIf the tracker algorithm does not generate confidence value, then tracker confidence value will be set to the default value (i.e.,1.0) for tracked objects. For IOU, NvSORT and NvDeepSORT trackers,tracker_confidenceis set to1.0as these algorithms do not generate confidence values for tracked objects. NvDCF tracker, on the other hand, generates confidence for the tracked objects due to its visual tracking capability, and its value is set intracker_confidencefield inNvDsObjectMetastructure.Note that there are separate parameters inNvDsObjectMetafor detector’s confidence and tracker’s confidence, which areconfidenceandtracker_confidence, respectively. More details can be found inNew metadata fieldsThe following table summarizes the features of the plugin.Gst-nvtracker plugin features#FeatureDescriptionReleaseConfigurable tracker width/heightFrames are internally scaled in NvTracker plugin to the specified resolution for tracking and passed to the low-level libDS 2.0Multi-stream CPU/GPU trackerSupports tracking on batched buffers consisting of frames from multiple sourcesDS 2.0NV12 InputDS 2.0RGBA InputDS 3.0Configurable GPU deviceUser can select GPU for internal scaling/color format conversions and trackingDS 2.0Dynamic addition/deletion of sources at runtimeSupports tracking on new sources added at runtime and cleanup of resources when sources are removedDS 3.0Support for user’s choice of low-level libraryDynamically loads user selected low-level libraryDS 4.0Support for batch processing exclusivelySupports sending frames from multiple input streams to the low-level libraryDS 4.0Multiple buffer formats as input to low-level libraryConverts input buffer to formats requested by the low-level library, for up to 4 formats per frameDS 4.0Enabling tracking-id displaySupports enabling or disabling display of tracking-idDS 5.0Tracking ID reset based on eventBased on the pipeline event (i.e., GST_NVEVENT_STREAM_EOS and GST_NVEVENT_STREAM_RESET),  the tracking IDs on a particular stream can be reset to start from 0 or new IDs.DS 6.0Miscellaneous dataSupports outputting user defined miscellaneous data (including the past-frame data, a list of terminated tracks, etc. ) if the low-level library supports the capabilityDS 6.3Re-ID tensor outputSupports outputting objects’ Re-ID features (i.e., embeddings) if the low-level library uses a Re-ID modelDS 6.3Support for NVIDIA’sVPI™based Crop-scaler and DCF-Tracker algorithms in NvDCF tracker (Alpha feature)Configuration options provided in NvDCF tracker which allow the user to switch to NVIDIA’sVPI™implementation of Crop-scaler and DCF-Tracker. The user can also configure the compute backend to be used amongst the backends supported byVPI™DS 6.4PVA-backend for NvDCF viaVPI™’s unified API (Alpha feature)Allow PVA-based execution of a significant part of NvDCF on Jetson, resulting in lower GPU utilizationDS 6.4Sub-batching (Alpha feature)Supports splitting of a batch of frames in sub-batches which are internally processed in parallel resulting in higher resource utilization. This feature also enables specification of a different config file for each sub-batch.DS 6.4Single-View 3D Tracking (Alpha feature)Allow 3D world coordinate system based object tracking when camera/model info (3x4 projection matrix and 3D human model info) is provided for better handling of partial occlusionDS 6.4Gst Properties#The following table describes the Gst properties of the Gst-nvtracker plugin.Gst-nvtracker plugin Gst Properties#PropertyMeaningType and RangeExample Notestracker-widthFrame width at which the tracker is to operate, in pixels. (To be a multiple of 32 when visualTrackerType: 1 or reidType is non-zero with useVPICropScaler: 0)Integer, 0 to 4,294,967,295tracker-width=640tracker-heightFrame height at which the tracker is to operate, in pixels. (To be a multiple of 32 when visualTrackerType: 1 or reidType is non-zero with useVPICropScaler: 0)Integer, 0 to 4,294,967,295tracker-height=384ll-lib-filePathname of the low-level tracker library to be loaded by Gst-nvtracker.Stringll-lib-file=­/opt/nvidia/­deepstream/­deepstream/­lib/libnvds_nvmultiobjecttracker.soll-config-fileConfiguration file for the low-level library if needed.(Alpha feature) A list of configuration files can be specified when the propertysub-batchesis configured.Path to configuration file ORA list of paths to configuration files delimited by semicolonll-config-file=config_tracker_NvDCF_perf.ymlll-config-file=config_tracker_NvDCF_perf1.yml;
config_tracker_NvDCF_perf2.ymlgpu-idID of the GPU on which device/unified memory is to be allocated, and with which buffer copy/scaling is to be done. (dGPU only.)Integer, 0 to 4,294,967,295gpu-id=0tracking-surface-typeSet surface stream type for tracking. (default value is 0)Integer, ≥0tracking-surface-type=0display-tracking-idEnables tracking ID display on OSD.Booleandisplay-tracking-id=1compute-hwCompute engine to use for scaling.0 - Default1 - GPU2 - VIC (Jetson only)Integer, 0 to 2compute-hw=1tracking-id-reset-modeAllow force-reset of tracking ID based on pipeline event. Once tracking ID reset is enabled and such event happens, the lower 32-bit of the tracking ID will be reset to 00: Not reset tracking ID when stream reset or EOS event happens1: Terminate all existing trackers and assign new IDs for a stream when the stream reset happens (i.e., GST_NVEVENT_STREAM_RESET)2: Let tracking ID start from 0 after receiving EOS event  (i.e., GST_NVEVENT_STREAM_EOS) (Note: Only the lower 32-bit of tracking ID to start from 0)3: Enable both option 1 and 2Integer, 0 to 3tracking-id-reset-mode=0input-tensor-metaUse the tensor-meta from Gst-nvdspreprocess if available for tensor-meta-gie-idBooleaninput-tensor-meta=1tensor-meta-gie-idTensor Meta GIE ID to be used, property valid only if input-tensor-meta is TRUEUnsigned Integer, ≥0tensor-meta-gie-id=5sub-batches (Alpha feature)Configures splitting of a batch of frames in sub-batches. There are two ways to configure sub-batches.First option allows static mapping of each source id to individual sub-batch.Second option lets the user configure the sub-batch sizes. Mapping of individual streams to sub-batch happens dynamically at runtime.Option 1 : Semicolon delimited integer array where each number corresponds to source id.Must include all values from 0 to (batch-size -1) where batch-size is configured in[streammux].Option 2 : Colon delimited integer array where each number corresponds to size of a sub-batch (i.e. max number of stream a sub-batch can accommodate)Option 1 : sub-batches=0,1;2,3In this example, a batch size of 4 is split into two sub-batches where the first sub-batch consists of source ids 0 & 1 and second sub-batch consists of source ids 2 & 3Option 2 : sub-batches=2:1The above example indicates that there are two sub-batches, first one can accommodate 2 streams and second one can accommodate 1.sub-batch-err-recovery-trial-cnt (Alpha feature)Configure the number of times the plugin can try to recover when the low level tracker in a sub-batch returns with a fatal error.To recover from the error, the plugin reinitializes the low level tracker library.Integer,≥-1  where,-1 corresponds to infinite trialssub-batch-err-recovery-trial-cnt=3user-meta-pool-sizeThe size of tracker miscellaneous data buffer poolUnsigned Integer, >0user-meta-pool-size=32NvDsTracker API for Low-Level Tracker Library#A low-level tracker library can be implemented using the API defined insources/includes/nvdstracker.h. Parts of the API refer tosources/includes/nvbufsurface.h. The names of API functions and data structures are prefixed withNvMOT, which stands for NVIDIA Multi-Object Tracker. Below is the general flow of the API from a low-level library’s perspective:The first required function is:NvMOTStatusNvMOT_Query(uint16_tcustomConfigFilePathSize,char*pCustomConfigFilePath,NvMOTQuery*pQuery);The plugin uses this function to query the low-level library’s capabilities and requirements before it starts any processing sessions (i.e., contexts) with the library. Queried properties include the input frame’s color format (e.g., RGBA or NV12) and memory type (e.g., NVIDIA®CUDA®device or CPU-mapped NVMM).The plugin performs this query once during initialization stage, and its results are applied to all contexts established with the low-level library. If a low-level library configuration file is specified, it is provided in the query for the library to consult.
The query reply structure,NvMOTQuery, contains the following fields:NvMOTComputecomputeConfig: Report compute targets supported by the library. The plugin currently only echoes the reported value when initiating a context.uint8_tnumTransforms: The number of color formats required by the low-level library. The valid range for this field is0toNVMOT_MAX_TRANSFORMS. Set this to0if the library does not require any visual data.Note0does not mean that untransformed data will be passed to the library.NvBufSurfaceColorFormatcolorFormats[NVMOT_MAX_TRANSFORMS]: The list of color formats required by the low-level library. Only the firstnumTransformsentries are valid.NvBufSurfaceMemTypememType: Memory type for the transform buffers. The plugin allocates buffers of this type to store color- and scale-converted frames, and the buffers are passed to the low-level library for each frame.
The support is currently limited to the following types:dGPU:NVBUF_MEM_CUDA_PINNEDNVBUF_MEM_CUDA_UNIFIEDJetson:NVBUF_MEM_SURFACE_ARRAYboolsupportBatchProcessing: True if the low-level library supports the batch processing across multiple streams; otherwise false.boolsupportPastFrame: True if the low-level library supports outputting the past-frame data; otherwise false.After the query, and before any frames arrive, the plugin must initialize a context with the low-level library by calling:NvMOTStatusNvMOT_Init(NvMOTConfig*pConfigIn,NvMOTContextHandle*pContextHandle,NvMOTConfigResponse*pConfigResponse);The context handle is opaque outside the low-level library. In the batch processing mode, the plugin requests a single context for all input streams. In per-stream processing mode, on the other hand, the plugin makes this call for each input stream so that each stream has its own context.
This call includes a configuration request for the context. The low-level library has an opportunity to:Review the configuration and create a context only if the request is accepted. If any part of the configuration request is rejected, no context is created, and the return status must be set toNvMOTStatus_Error. ThepConfigResponsefield can optionally contain status for specific configuration items.Pre-allocate resources based on the configuration.NoteIn theNvMOTMiscConfigstructure, thelogMsgfield is currently unsupported and uninitialized.ThecustomConfigFilePathpointer is only valid during the call.Once a context is initialized, the plugin sends frame data along with detected object bounding boxes to the low-level library whenever it receives such data from upstream. It always presents the data as a batch of frames, although the batch can contain only a single frame in per-stream processing contexts. Note that depending on the frame arrival timings to the tracker plugin, the composition of frame batches could either be afull batch(that contains a frame from every stream) or apartial batch(that contains a frame from only a subset of the streams). In either case, each batch is guaranteed to containat most one framefrom each stream.The function call for this processing is:NvMOTStatusNvMOT_Process(NvMOTContextHandlecontextHandle,NvMOTProcessParams*pParams,NvMOTTrackedObjBatch*pTrackedObjectsBatch);, where:pParamsis a pointer to the input batch of frames to process. The structure contains a list of one or more frames, with at most one frame from each stream. Thus, no two frame entries have the samestreamID. Each entry of frame data contains a list of one or more buffers in the color formats required by the low-level library, as well as a list of object attribute data for the frame. Most libraries require at most one-color format.pTrackedObjectsBatchis a pointer to the output batch of object attribute data. It is pre-populated with a value fornumFilled, which is the same as the number of frames included in the input parameters.If a frame has no output object attribute data, it is still counted innumFilledand is represented with an empty list entry (NvMOTTrackedObjList). An empty list entry has the correctstreamIDset and numFilled set to0.NoteThe output object attribute dataNvMOTTrackedObjcontains a pointer to the detector object (provied in the input) that is associated with a tracked object, which is stored inassociatedObjectIn. You must set this to the associated input object only for the frame where the input object is passed in. For a pipeline with PGIEinterval=1, for example:Frame 0:NvMOTObjToTrackXis passed in. The tracker assigns it ID 1, and the output object’sassociatedObjectInpoints toX.Frame 1: Inference is skipped, so there is no input object from detector to be associated with. The tracker finds Object 1, and the output object’sassociatedObjectInpoints toNULL.Frame 2:NvMOTObjToTrackYis passed in. The tracker identifies it as Object 1. The output Object 1 hasassociatedObjectInpointing toY.Depending on the capability of the low-level tracker, there could be some user-defined miscellaneous data to report to tracker plugin.batch_user_meta_listinNvDsBatchMetaas a user-meta:NvMOTStatusNvMOT_RetrieveMiscData(NvMOTContextHandlecontextHandle,NvMOTProcessParams*pParams,NvMOTTrackerMiscData*pTrackerMiscData);where:pParamsis a pointer to the input batch of frames to process. This structure is needed to check the list of stream ID in the batch.pTrackerMiscDatais a pointer to the output miscellaneous data for the current batch to be filled by the low-level tracker. The data structureNvMOTTrackerMiscDatais defined innvdstracker.h.In case that a video stream source is removed on the fly, the plugin calls the following function so that the low-level tracker library can remove it as well. Note that this API is optional and valid only when the batch processing mode is enabled, meaning that it will be executed only when the low-level tracker library has an actual implementation for the API. If called, the low-level tracker library can release any per-stream resource that it may be allocated:voidNvMOT_RemoveStreams(NvMOTContextHandlecontextHandle,NvMOTStreamIdstreamIdMask);When all processing is complete, the plugin calls this function to clean up the context and deallocate its resources:voidNvMOT_DeInit(NvMOTContextHandlecontextHandle);NvMultiObjectTracker: A Reference Low-Level Tracker Library#Multi-object tracking (MOT) is a key building block for a large number of intelligent video analytics (IVA) applications that requires spatio-temporal analysis of objects of interest to draw further insights about the objects’ behaviors in long term. Given a set of detected objects from the Primary GIE (PGIE) module on a single or multiple streams and with the APIs defined to work with the tracker plugin, the low-level tracker library is expected to carry out actual multi-object tracking operations to keep persistent IDs to the same objects over time.DeepStream SDK provides a single reference low-level tracker library, calledNvMultiObjectTracker, that implements all four low-level tracking algorithms (i.e., IOU, NvSORT, NvDeepSORT, and NvDCF) in a unified architecture. It supports multi-stream, multi-object tracking in the batch processing mode for efficient processing on CPU and GPU (andPVAfor Jetson). The following sections will cover the unified tracker architecture and the details of each reference tracker implementation.Unified Tracker Architecture for Composable Multi-Object Tracker#InNvMultiObjectTrackerlow-level tracker library, different types of multi-object trackers share common modules when it comes to basic functionalities (e.g., data association, target management, state estimation, etc.), while differing in other core functionalities (e.g., visual tracking for NvDCF and deep association metric for NvDeepSORT). TheNvMultiObjectTrackerlibrary employs a unified architecture to allow thecompositionof a multi-object tracker through configuration by enabling only the modules required for a particular object tracker. The IOU tracker, for example, requires a minimum set of modules that consist of data association and target management modules. On top of that, NvSORT adds a state estimator for more accurate motion estimation & prediction, and NvDeepSORT further introduces a deep Re-ID network to integrate appearance information into data association. Instead of the deep neural network-based Re-ID features in NvDeepSORT, NvDCF employs a Discriminative Correlation Filter (DCF)-based visual tracking module that uses conventional feature descriptors for more efficient tracking. However, NvDCF can still allow the use of Re-ID module for target re-association for longer-term robustness.The table below summarizes what modules are used to compose each object tracker, showing what modules are shared across different object trackers and how each object tracker differs in module composition:Tracker TypeStateEstimatorTargetManagementVisualTrackerTarget
Re-AssociationData Association MetricSpatio-
temporalRe-IDProximity
& SizeVisual
SimilarityRe-IDIOUOONvSORTOOONvDeepSORTOOOONvDCFOOOOOOOIn the following sections, we will first discuss the general work flow of the NvMultiObjectTracker library and its core modules, and then each type of object trackers in more details with explanations on the config params in each module.Workflow and Core Modules in TheNvMultiObjectTrackerLibrary#The input to a low-level tracker library consists of (1) a batch of video frames from a single or multiple streams and (2) a list of detector objects for each video frame. If the detection interval (i.e.,intervalin Primary GIE section) is set larger than 0, the input data to the low-level tracker would have the detector object data only when the inferencing for object detection is performed for a video frame batch (i.e., theinferencedframe batch). For the frame batches where the inference is skipped (i.e., theuninferencedframe batch), the input data would include only the video frames.NoteAdetector objectrefers to an object that is detected by the detector in PGIE module, which is provided to the multi-object tracker module as an input.Atargetrefers to an object that is being tracked by the object tracker.Aninferencedframe is a video frame where an inference is carried out for object detection. Since the inference interval can be configured in setting for PGIE and can be larger than zero, theframeNumof two consecutive inferenced frames may not be contiguous.For carrying out multi-object tracking operations with the given input data, below are the essential functionalities to be performed. Multithreading is deployed to optimize their performance on CPU.Data associationbetween the detector objects from a new video frame and the existing targets for the same video streamTarget managementbased on the data association results, including the target state update and the creation and termination of targetsDepending on the tracker types, there could be some addition processing before data association. For example, NvDeepSORT extracts Re-ID features from all the detector objects and computes the similarity, while NvDCF performs the visual tracker based localization so the targets’ predicted locations in a new frame can be used for data association. More details will be covered in each tracker’s section.Data Association#For data association, various types of similarity metrics are used to calculate the matching score between the detector objects and the existing targets, including:Location similarity (i.e., proximity)Bounding box size similarityRe-ID feature similarity  (specific to NvDeepSORT tracker)Visual appearance similarity (specific to NvDCF tracker)For the proximity between detector objects and targets, IOU is a typical metric that is widely used, but it also depends on the size similarity between them. The similarity of the box size between two objects can be used explicitly, which is calculated as the ratio of the size of the smaller box over the larger one.The total association score for a pair of detector object and target is the weighted sum of all the metrics:\[totalScore=w_1*IOU+w_2*sizeSimilarity+w_3*reidSimilarity+w_4*visualSimilarity\]where\(w_i\)is the weight for each metric set in config file. Users can also set a minimum threshold for each similarity and the total score.During the matching, a detector object is associated with a target that belongs to the same class by default to minimize the false matching. However, this can be disabled by settingcheckClassMatch:0, allowing objects can be associated regardless of their object class IDs. This can be useful when employing a detector like YOLO, which can detect many classes of objects, where there could be false classification on the same object over time.Regarding the matching algorithm, users can setassociationMatcherTypeas0to employ an efficient greedy algorithm for optimal bipartite matching with similarity metrics defined above, or1for a newly introduced method namedcascaded data associationfor higher accuracy.
The cascaded data association consists of multi-stage matching, assigning different priorities and similarity metrics based on detection and target confidence. Detector objects are split into two sets, confirmed (confidence between [tentativeDetectorConfidence, 1.0]) and tentative (confidence between [minDetectorConfidence,tentativeDetectorConfidence]). Then three stage matching are performed sequentially:Confirmed detections and validated (both active and inactive) targetsTentative detections and active targets leftConfirmed detections left and tentative targetsThe first stage uses the joint-similarity metrics defined above, while the later two stages only considers the IOU similarity, because proximity can be a more reliable metric than visual similarity or Re-ID when the detection confidence is low due to, say, partial occlusions or noise. Each stage takes different sets of bboxes as candidates and uses the efficient greedy algorithm for matching. The matched pairs are produced from each stage and combined together.The output of the data association module consists of three sets of objects/targets:The unmatched detector objectsThe matched pairs of the detector objects and the existing targetsThe unmatched targetsThe unmatched detector objects are among the objects detected by a PGIE detector, yet not associated with any of the existing targets. An unmatched detector object is considered as a newly observed object that needs to be tracked, unless they are determined to be duplicates to any of the existing target. If the maximum IOU score of a new detector object to any of the existing targets is lower thanminIouDiff4NewTarget, a new target tracker would be created to track the object since it is not a duplicate to an existing target.Target Management and Error Handling#Although a new object is detected by the detector (i.e., a detector object), there is a possibility that this may be a false positive. To suppress such noise in detection, theNvMultiObjectTrackertracker library employs a technique calledLate Activation, where a newly detected object is examined for a period of time and activated for long-term trackingonly ifit survives such a period. To be more specific, whenever a new object is detected, a new tracker is created to track the object, but the target is initially put into theTentativemode, which is a probationary period, whose length is defined byprobationAgeunderTargetManagementsection of the config file. During this probationary period, the tracker output will not be reported to the downstream, since the target is not validated yet; however, those unreported tracker output data (i.e.,the past-frame data) are stored within the low-level tracker for later report.The same target may be detected for the next frame; however, there could befalse negativeby the detector (i.e., missed detection), resulting in a unsuccessful data association to the target. The NvMultiObjectTracker library employs another technique calledShadow Tracking, where a target is still being tracked in the background for a period of time even when the target isnotassociated with a detector object. Whenever a target is not associated with a detector object for a given time frame, an internal variable of the target calledshadowTrackingAgeis incremented. Once the target is associated with a detector object, thenshadowTrackingAgewill be reset to zero.If the target is in the Tentative mode and theshadowTrackingAgereachesearlyTerminationAgespecified in the config file, the target will be terminated prematurely (which is referred to asEarly Termination). If the target is not terminated during the Tentative mode and successfully assocciated with a detector object, the target isactivatedand put into theActivemode, starting to report the tracker outputs to the downstream. If the past-frame data is enabled, the tracked data during the Tentative mode will be reported as well, since they were not reported yet. Once a target is activated (i.e., in Active mode), if the target is not associated for a given time frame (or the tracker confidence gets lower than a threshold), it will be put into theInactivemode, and itsshadowTrackingAgewill be incremented, yet still be tracked in the background. However, the target will be terminated if theshadowTrackingAgeexceedsmaxShadowTrackingAge.The state transitions of a target tracker are summarized in the following diagram:The NvMultiObjectTracker library can generate a unique ID to some extent. If enabled by settinguseUniqueID:1, each video stream will be assigned a 32-bit long random number during the initialization stage. All the targets created from the same video stream will have the same upper 32-bit of theuint64_t-type target ID set by the per-stream random number. In the meantime, the lower 32-bit of the target ID starts from 0. The randomly generated upper 32-bit number allows the target IDs from a particular video stream to increment from a random position in the possible ID space. If disabled (i.e.,useUniqueID:0, which is the default value), both the upper and lower 32-bit will start from 0, resulting in the target ID to be incremented from 0 for every run.Note that the incrementation of the lower 32-bit of the target ID is done across the whole video streams in the same NvMultiObjectTracker library instantiation. Thus, even if the unique ID generation is disabled, the tracker IDs will be unique for the same pipeline run. If the unique ID generation is disabled, and if there are three objects for Stream 1 and two objects for Stream 2, for example, the target IDs will be assigned from 0 to 4 (instead of 0 to 2 for Stream 1 and 0 to 1 for Stream 2) as long as the two streams are being processed by the same library instantiation.preserveStreamUpdateOrdercontrols whether to use single or multiple threads to update targets. If it is enabled, new IDs are generated sequentially following input stream ID order in each batch using a single thread, i.e. the objects for Stream 1 and 2 will have IDs from 0 to 2 and 3 to 4 respectively. By default, this option is disabled so target management is done with multi-threads to enable better performance but the ID order is not preserved. If the user needs consistent IDs over multiple runs for the same video source, please setpreserveStreamUpdateOrder:1andbatched-push-timeout=-1in deepstream-app config.The NvMultiObjectTracker librarypre-allocatesall the GPU memories during initialization based on:The number of streams to be processedThe maximum number of objects to be tracked per stream (denoted asmaxTargetsPerStream)Thus, the CPU/GPU memory usage by the NvMultiObjectTracker library is almost linearly proportional to the total number of objects being tracked, which is(number of video streams) × (maxTargetsPerStream), except the scratch memory space used by dependent libraries (such as cuFFT™, TensorRT™, etc.). Thanks to the pre-allocation of all the necessary memory, the NvMultiObjectTracker library is not expected to have memory growth during long-term run even when the number of objects increases over time.Once the number of objects being tracked reaches the configured maximum value (i.e.,maxTargetsPerStream), any new objects will be discarded until some of the existing targets are terminated. Note that the number of objects being tracked includes the targets that are being tracked in the shadow tracking mode. Therefore, NVIDIA recommends that users setmaxTargetsPerStreamlarge enough to accommodate the maximum number of objects of interest that may appear in a frame, as well as the objects that may have been tracked from the past frames in the shadow tracking mode.TheminDetectorConfidenceproperty underBaseConfigsection in a low-level tracker config file sets the confidence level below which the detector objects are filtered out.State Estimation#The NvMultiObjectTracker library employs two types of state estimators, both of which are based on Kalman Filter (KF): Simple-bbox KF, Regular-bbox KF, and Simple-location KF. TheSimple-bbox KFhas6states defined, which are{x,y,w,h,dx,dy}, wherexandyindicate the coordinates of the top-left corner of a target bbox, whilewandhthe width and the height of the bbox, respectively.dxanddydenote the velocity ofxandystates. TheRegular-bbox KF, on the other hand, have8states defined, which are{x,y,w,h,dx,dy,dw,dh}, wheredwanddhare the velocity ofwandhstates and the rest is the same as the Simple-bbox KF. TheSimple-location KFhas4states only, which are{x,y,dx,dy}. Unlike the the two KFs that estimate the bbox attributes, note that the Simple-location KF is meant to estimate the object location in either 2D camera image plane or 3D world ground plane.All the Kalman Filter types employ a constant velocity model for generic use. The measurement vector for the Simple-bbox and Regular-bbox KF is defined as{x,y,w,h}, which represents the bbox attributes, while that for the Simple-location KF is defined as{x,y}. There is an option to use bbox aspect ratioaand its velocitydainstead ofwanddwwhenuseAspectRatiois enabled, which is specially used by NvDeepSORT. In case the state estimator is used for a generic use case (like in the NvDCF tracker), the process noise variance for{x,y},{w,h}, and{dx,dy,dw,dh}can be configured byprocessNoiseVar4Loc,processNoiseVar4Size, andprocessNoiseVar4Vel, respectively.When a visual tracker module is enabled (like in the NvDCF tracker), there could be two different measurements from the state estimator’s point of view: (1) the bbox (or location) from the detector at PGIE and (2) the bbox (or location) from the tracker’s localization. This is because the NvDCF tracker module is capable of localizing targets using its own learned filter. The measurement noise variance for these two different types of measurements can be configured bymeasurementNoiseVar4DetectorandmeasurementNoiseVar4Tracker. These parameters are expected to be tuned or optimized based on the detector’s and the tracker’s characteristics for better measurement fusion.The usage of the state estimator in the NvDeepSORT tracker slightly differs from that for the aforementioned generic use case in that it is basically aRegular KF, yet with a couple of differences as per the original paper and the implementation (Check the references inNvDeepSORT Trackersection):Use of the aspect ratioaand the heighth(instead ofwandh) to estimate the bbox sizeThe process and measurement noises that are proportional to the bounding box height (instead of constant values)To allow these differences, the state estimator module in the NvMultiObjectTracker library has a set of additional config parameters:useAspectRatioto enable the use ofa(instead ofw)noiseWeightVar4LocandnoiseWeightVar4Velas the proportion coefficients for the measurement and velocity noise, respectivelyNote that if these two parameters are set, the fixed process noise and measurement noise parameters for the generic use cases will be ignored.Object Re-Identification#Re-identification (Re-ID) uses TensorRT™-accelerated deep neural networks to extract unique feature vectors from detected objects that are robust to spatial-temporal variance and occlusion. It has two use-cases inNvMultiObjectTracker: (1) In NvDeepSORT, the Re-ID similarity is used for data association of objects over consecutive frames.; (2) In target re-association (which will be described in more detail in the following section), the Re-ID features of targets are extracted and kept, so that they can be used for re-association with the same target if they are seemingly lost.reidTypeselects the mode for each aforementioned use-case.In the Re-ID module, the detector objects are cropped and resized into the configured input size of the Re-ID network. The parameterkeepAspccontrols whether the object’s aspect ratio is preserved after cropping. Then NVIDIA TensorRT™ creates an engine from the network, which processes the input in batches and outputs a fixed-dimensional vector for each detector object as the Re-ID feature. The cosine similarity function requires each feature’s L2 norm normalized to 1. CheckRe-ID Feature Outputon how to retrieve these features in the tracker plugin and downstream modules. For each target, a gallery of its Re-ID features in most recent frames are kept internally. The size of the feature gallery can be set byreidHistorySize.Noteconfig_tracker_NvDeepSORT.ymlandconfig_tracker_NvDCF_accuracy.ymlconfigs use ReIdentificationNet by default, which is a ResNet-50 Re-ID network in NVIDIA TAO toolkit onNGC. Users need to follow instructions inSetup Sample Re-ID Modelsto setup, or checkCustomize Re-ID Modelfor more information on adding a custom Re-ID model for object tracking with different architectures and datasets.The Re-ID similarity between a detector object and a target is the cosine similarity between the detector object’s Re-ID feature and its nearest neighbor in the target’s featue gallery, whose value is in range[0.0,1.0]. Specifically, each Re-ID feature in the target’s gallery takes the dot product with the detector object’s Re-ID feature. The maximum of all the dot products is the similarity score, i.e.\[score_{ij}=\max_{k}(feature\_det_{i}\cdot feature\_track_{jk})\]where:\(\cdot\)denotes the dot product.\(feature\_det_{i}\)denotes the i-th detector object’s feature.\(feature\_track_{jk}\)denotes the k-th Re-ID feature in the j-th target’s feature gallery.\(k\)=[1,reidHistorySize].The Re-ID has a spatial-temporal constraint. If an object moves out of frame or gets occluded beyondmaxShadowTrackingAge, it will be assigned a new ID even if it returns into the frame.The extracted Re-ID features (i.e., embeddings) can be exported to the metadata, which is explained in a separate section inRe-ID Feature Output.Target Re-Association#Thetarget re-associationalgorithm enhances the long-term robustness of multi-object tracking by jointly using the Re-ID and spatio-temporal (i.e., motion) features. It addresses one of the major tracking failure cases that occurs in the situation where objects undergo partial- or full-occlusions in a gradual or abrupt manner. During this course of action, the detector at PGIE module may capture only some part of the objects (due to partial visibility), resulting in ill-sized, ill-centered boxes on the target. Later, the target cannot be associated with the object appearing again due to the size and location prediction errors, potentially causing tracking failures and ID switches. Such a re-association problem can typically be handled as a post-processing; however, for real-time analytics applications, this is often expected to be handled seamlessly as a part of the real-time multi-object tracking.The target re-association takes advantage of theLate ActivationandShadow Trackingin target management module. It tries to associate the newly-appeared targets with previously lost targets based on motion and Re-ID similarity in a seamless, real-time manner by the following steps:Tracklet Prediction: Whenever an existing target is not associated with a detector object for a prolonged period (same asprobationAge), it is considered that the target is lost. While the visual tracker module keeps track of the target in the shadow tracking mode, a length of the predicted tracklet (configured bytrajectoryProjectionLength) is generated using some of the recently matched tracklet points (whose length is set byprepLength4TrajectoryProjection) and stored into an internal database until it is matched again with a detector object or re-associated with another target.Re-ID Feature Extraction: Before a target is lost, the Re-ID network extracts its Re-ID feature with the frame interval ofreidExtractionIntervaland stores them in the feature gallery. These features will be used to identify target re-appearance in the tracklet matching stage.Target ID Acquisition: When a new target is instantiated, its validity is examined for a few frames (i.e.,probationAge) and a target ID is assigned only if validated (i.e., Late Activation), after which the target state report starts. During the target ID acquisition, the new target is examined if it matches with one of the predictedtrackletsfrom the existing targets in the internal database where the aforementioned predictedtrackletsare stored. If matched, it would mean that the new target is actually the re-appearance of a disappeared target in the past. Then, the new target is re-associated with the existing target and itstrackletis fused into that as well. Otherwise, a new target ID is assigned.Tracklet Matching: During thetrackletmatching process in the previous step, the valid candidatetrackletsare queried from the database based on the feasible time window configured bymaxTrackletMatchingTimeSearchRange. For the new target and each candidate, both the motion and Re-ID similarity are taken into account for tracklet matching. The motion similarity is the average IOU along thetrackletwith various criteria including the minimum average IOU score (i.e.,minTrackletMatchingScore), maximum angular difference in motion (i.e.,maxAngle4TrackletMatching), minimum speed similarity (i.e.,minSpeedSimilarity4TrackletMatching), and minimum bbox size similarity (i.e.,minBboxSizeSimilarity4TrackletMatching) computed by a Dynamic Time Warping (DTW)-like algorithm. The Re-ID similarity is the cosine distance between the new target’s Re-ID feature and its nearest neighbor in the candidate’s feature gallery. The total similarity score is the weighted sum of both metrics:\[totalScore=w_1*IOU+w_2*reidSimilarity\]where\(w_i\)is the weight for each metric set in config file. Users can also set a minimum threshold for each similarity and the total score.Tracklet Fusion: Once twotrackletsare associated, they are fused together to generate one smoothtrackletbased on the matching status with detector and the confidence at each point.config_tracker_NvDCF_accuracy.ymlprovides an example to enable this feature. Since Re-ID is computationally expensive, users may choose to increasereidExtractionIntervalto improve performance or set the parameters like below (i.e., disabling Re-ID feature extraction) to use motion-only target re-association without Re-ID.TrajectoryManagement:useUniqueID:0# Use 64-bit long Unique ID when assignining tracker ID. Default is [true]enableReAssoc:1# Enable Re-AssocminMatchingScore4Overall:0# min matching score for overallminTrackletMatchingScore:0.5644# min tracklet similarity score for re-assocmatchingScoreWeight4TrackletSimilarity:1.0# weight for tracklet similarity scoreminTrajectoryLength4Projection:36# min trajectory length required to make projected trajectoryprepLength4TrajectoryProjection:50# the length of the trajectory during which the state estimator is updated to make projectionstrajectoryProjectionLength:94# the length of the projected trajectorymaxAngle4TrackletMatching:106# max angle difference for tracklet matching [degree]minSpeedSimilarity4TrackletMatching:0.0967# min speed similarity for tracklet matchingminBboxSizeSimilarity4TrackletMatching:0.5577# min bbox size similarity for tracklet matchingmaxTrackletMatchingTimeSearchRange:20# the search space in time for max tracklet similaritytrajectoryProjectionProcessNoiseScale:0.0100# trajectory projector's process noise scale w.r.t. state estimatortrajectoryProjectionMeasurementNoiseScale:100# trajectory projector's measurement noise scale w.r.t. state estimatortrackletSpacialSearchRegionScale:0.2598# the search region scale for peer trackletReID:reidType:0# The type of reid among { DUMMY=0, NvDEEPSORT=1, Reid based reassoc=2, both NvDEEPSORT and reid based reassoc=3}NoteTarget re-association can be effective only when the state estimator is enabled, otherwise thetrackletprediction will not be made properly. The parameters provided above is tuned for PeopleNet v2.6.2, and it may not work as expected for other types of detectors.Bounding-box Unclipping#Another small experimental feature is the bounding box unclipping. If a target is fully visible within the field-of-view (FOV) of the camera but starts going out of the FOV, the target would be partially visible and the bounding box (i.e.,bbox) may capture only a part of the target (i.e., clipped by the FOV) until it fully exits the scene. If it is expected that the size of thebboxdoesn’t change much around the border of the video frame, the fullbboxcan be estimated beyond the FOV limit using thebboxsize estimated when the target was fully visible. This feature can be enabled by settingenableBboxUnClipping:1underTargetManagementmodule in the low-level config file.Single-View 3D Tracking (Alpha)#As mentioned earlier, partial occlusion is one of the most challenging problems that object trackers have to deal with and often lead to tracking failures. If the object detectors capture only the visible part of the object (which is often the case), the partial occlusion would cause the detection bboxes to have abrupt or gradual changes in attributes in terms of bbox location, size, aspect ratio, confidence, and most importantly the visual appearance within the bbox. Considering the object trackers rely on the bbox attributes as spatio-temporal measure and the visual appearance (e.g., ReID embedding) extracted within the bbox as visual similarity measure, such changes in bbox attributes is a major source of tracking failures, resulting in more frequent ID switches.To tackle these challenging problems, DeepStream SDK introduced a new feature called theSingle-View 3D Tracking (SV3DT)that allows the object tracking to be carried out in a 3D world coordinate system (instead of the 2D camera image plane) when (1) a 3x4 projection matrix and (2) a 3D model info are provided for a video stream in a camera info file like below.# camInfo-01.yml# The 3x4 camera projection matrix (in row-major):#    996.229 -202.405  -9.121 -1.185#    105.309  478.174 890.944 1.743#    -0.170   -0.859   0.481  -1085.484projectionMatrix_3x4:-996.229--202.405--9.121--1.185-105.309-478.174-890.944-1.743--0.170--0.859-0.481--1085.484# The cylindrical human modelmodelInfo:height:250.0radius:30.0There are two options (projectionMatrix_3x4andprojectionMatrix_3x4_w2p) in which users can provide corresponding 3x4 camera projection matrices to support different usecase. Please refer toThe 3x4 Camera Projection Matrixsection for more details.Note that there are a few assumptions that this algorithm requires:A human is modeled as a cylinder with height and radius in 3D world coordinate system, and the height and radius are provided as 3D model info.A 3x4 projection matrix (that transforms a 3D world coordinate point to a 2D camera image coordinate point) is provided for a video stream or a camera.Video streams are captured from cameras that are mounted higher than the human height.The third assumption ensures that when a human is partially-occluded, the head is still visible, allowing us to use the top bbox edge as an anchor, which we will touch upon shortly.For each detection bounding box for a person, SV3DT algorithm tries to fit the 3D human model to the detection bbox in such a way that the bounding box of the projected 3D human model from the world coordinate system to the camera image plane matches with the detection bbox.A figure below shows how cylindrical 3D human models can be fitted to the input detection bboxes.In the cases where a person is partially occluded, the top edge of the detection bbox is used as an anchor to align the bbox of the projected 3D human model. Once aligned, we can recover the full-body bbox using the projected 3D human model, as if the person is not occluded. Therefore, if SV3DT is enabled, the input detection bboxes are always firstrecoveredto the full-body bboxes based on the provided 3D model info especially when the input detection bboxes capture only the visible part of the person due to partial occlusions. This greatly enhances the multi-object tracking accuracy and robustness, since the bbox attributes are not altered during the course of partial occlusions.An animated image below shows how cylindrical 3D human models can be fitted into the input detection bboxes when the persons are partially occluded. The thin, gray bboxes on the persons indicate the input detection bboxes, which capture only the visible part of the objects. The figure demonstrates that the SV3DT algorithm is still able to estimate the accurate foot location of each person. The person trajectories are drawn based on the estimated foot locations, allowing robust spatio-temporal behavior analytics of persons in the scene despite varying degree of occlusions. Some of the persons in this example are barely seen only on the head and shoulders, but they are being successfully tracked as if not occluded at all.As a derived metric, the ratio between the bbox for the visible part and the bbox for the projected 3D human model can be considered as an approximatedvisibilityof the object, which could be a useful information.Users can still get access to the corresponding detection bboxes by checking outdetector_bbox_infoinNvDsObjectMeta.To enable SV3DT feature, we introduced a new section in tracker config files,ObjectModelProjection, like below:ObjectModelProjection:cameraModelFilepath:# In order of the source streams-'camInfo-01.yml'-'camInfo_02.yml'...Every camera view is different, so the 3x4 projection matrix is supposed to be unique to each camera. Therefore, the camera info file (e.g.,camInfo-01.yml) is to be provided for each stream, which include the 3x4 projection matrix and the model info that are shown at the beginning of the section.Once a 3D human model corresponding to an input detection bbox is estimated and located in the world coordinate system, the foot location (i.e., the center of the base of the cylindrical model) of a person on the world ground plane is what we want to keep estimating because it is a physical state that better follows the motion dynamics modeling than the motion of the object on 2D camera image plane. To perform the state estimation of the foot location of the objects on a 3D world ground plane, users need to set the state estimator type asstateEstimatorType:3like below:StateEstimator:stateEstimatorType:3# the type of state estimator among { DUMMY_ESTIMATOR=0, SIMPLE_BBOX_KF=1, REGULAR_BBOX_KF=2, SIMPLE_LOCATION_KF=3 }# [Dynamics Modeling]processNoiseVar4Loc:6810.866# Process noise variance for locationprocessNoiseVar4Vel:1348.487# Process noise variance for velocitymeasurementNoiseVar4Detector:100.000# Measurement noise variance for detector's detectionmeasurementNoiseVar4Tracker:293.323# Measurement noise variance for tracker's localizationAn additional miscellaneous data that can be useful for debugging or visualization is the convex hull of the projected 3D human model on 2D camera image plane. By using the convex hull data for each object, users can also create the visualization like the figures above.The additional miscellaneous data that is generated when SV3DT is enabled include (1) visibility, (2) foot location in both world plane and 2D image, and (3) convex hull (human cylinders projected on 2D image). These data can be saved in text files and/or outputted to object meta for downstream usage. To do that, users would need to setoutputVisibility:1,outputFootLocation:1,outputConvexHull:1inObjectModelProjectionsection respectively. The sample use cases includes saving in terminated track dump for low level tracker, attaching in KITTI track dump for deepstream-app, and converting them in schema throughGst-nvmsgconv.To allow users to easily try out and experience SV3DT,a sample usecase for SV3DThas been hosted on GitHub. So, users can just clone and run it with the sample data provided.The 3x4 Camera Projection Matrix#The 3x4 Camera Projection Matrix is also called as simply the camera matrix, which is a 3x4 matrix that converts a 3D world point to a 2D point on camera image plane based on a pinhole camera model like shown in the figure below:Pinhole Camera Model. Source:OpenCV DocandLicense#More detailed and general information about the camera matrix  can be found in various sources that deal with the computer vision geometries and camera calibration, includingOpenCV’s documentation on Camera Calibration.ForprojectionMatrix_3x4in a camera model file (e.g.,camInfo-01.yml), the principal point (i.e.,(Cx,Cy)) in the camera matrix is assumed to be at(0,0)as image coordinates. But, the optical center (i.e.,(Cx,Cy)) is located at the image center (i.e.,(img_width/2,img_height/2)). Thus, to move the origin to the left-top of the camera image (i.e., the pixel coordinates), SV3DT internally adds(img_width/2,img_height/2)after the transformation using the camera matrix provided inprojectionMatrix_3x4.In case that the 3x4 camera projection matrix already accounts for such translation of the principal point, users can provide the camera matrix inprojectionMatrix_3x4_w2pinstead. This assumes that the 3x4 camera projection matrix transforms a 3D world point directly into an actual pixel point whose origin is at the left-top corner of the image, so it does not require any further translation of the principal point.Configuration Parameters#The following table summarizes the configuration parameters for the common modules in the NvMultiObjectTracker low-level tracker library.Configuration properties in Common Modules in NvMultiObjectTracker low-level tracker library#ModulePropertyMeaningType and RangeDefault valueBase ConfigminDetectorConfidenceMinimum detector confidence for a valid objectFloat,
-inf to infminDetectorConfidence: 0.0Target ManagementpreserveStreamUpdateOrderWhether to ensure target ID update order the same as input stream ID orderBooleanpreserveStreamUpdateOrder: 0maxTargetsPerStreamMax number of targets to track per streamInteger, 0 to 65535maxTargetsPerStream: 30minIouDiff4NewTargetMin IOU to existing targets for discarding new targetFloat,
0 to 1minIouDiff4NewTarget: 0.5enableBboxUnClippingEnable bounding-box unclippingBooleanenableBboxUnClipping: 0probationAgeLength of probationary period in #of framesInteger, ≥0probationAge: 5maxShadowTrackingAgeMaximum length of shadow trackingInteger, ≥0maxShadowTrackingAge: 38earlyTerminationAgeEarly termination ageInteger, ≥0earlyTerminationAge: 2outputTerminatedTracksOutput total frame history for terminated tracks to the tracker plugin for downstream usageBooleanoutputTerminatedTracks: 0outputShadowTracksOutput shadow track state information to the tracker plugin for downstream usageBooleanoutputShadowTracks: 0terminatedTrackFilenameFile name prefix to save terminated tracksStringterminatedTrackFilename: “”Trajectory ManagementuseUniqueIDEnable unique ID generation schemeBooleanuseUniqueID: 0enableReAssocEnable motion-based target re-associationBooleanenableReAssoc: 0minMatchingScore4OverallMin total score for re-associationFloat,
0.0 to 1.0minMatchingScore4Overall: 0.4minTrackletMatchingScoreMin tracklet similarity score for matching in terms of average IOU between trackletsFloat,
0.0 to 1.0minTrackletMatchingScore: 0.4minMatchingScore4ReidSimilarityMin ReID score for re-associationFloat,
0.0 to 1.0minMatchingScore4ReidSimilarity: 0.8matchingScoreWeight4TrackletSimilarityWeight for tracklet similarity term in re-assoc cost functionFloat,
0.0 to 1.0matchingScoreWeight4TrackletSimilarity: 1.0matchingScoreWeight4ReidSimilarityWeight for ReID similarity term in re-assoc cost functionFloat,
0.0 to 1.0matchingScoreWeight4ReidSimilarity: 0.0minTrajectoryLength4ProjectionMin tracklet length of a target (i.e., age) to perform trajectory projection [frames]Integer, >=0minTrajectoryLength4Projection: 20prepLength4TrajectoryProjectionLength of the trajectory during which the state estimator is updated to make projections [frames]Integer, >=0prepLength4TrajectoryProjection: 10trajectoryProjectionLengthLength of the projected trajectory [frames]Integer, >=0trajectoryProjectionLength: 90maxAngle4TrackletMatchingMax angle difference for tracklet matching [degree]Integer, [0, 180]maxAngle4TrackletMatching: 40minSpeedSimilarity4TrackletMatchingMin speed similarity for tracklet matchingFloat,
0.0 to 1.0minSpeedSimilarity4TrackletMatching: 0.3minBboxSizeSimilarity4TrackletMatchingMin bbox size similarity for tracklet matchingFloat,
0.0 to 1.0minBboxSizeSimilarity4TrackletMatching: 0.6maxTrackletMatchingTimeSearchRangeSearch space in time for max tracklet similarityInteger, >=0maxTrackletMatchingTimeSearchRange: 20trajectoryProjectionProcessNoiseScaleTrajectory state estimator’s process noise scaleFloat,
0.0 to inftrajectoryProjectionProcessNoiseScale: 1.0trajectoryProjectionMeasurement NoiseScaleTrajectory state estimator’s measurement noise scaleFloat,
0.0 to inftrajectoryProjectionMeasurement NoiseScale: 1.0trackletSpacialSearchRegionScaleRe-association peer tracklet search region scaleFloat,
0.0 to inftrackletSpacialSearchRegionScale: 0.0reidExtractionIntervalFrame interval to extract ReID features per target for re-association; -1 means only extracting the beginning frame per targetInteger, ≥-1reidExtractionInterval: 0Data AssociatorassociationMatcherTypeType of matching algorithm { GREEDY=0, CASCADED=1 }Integer, [0, 1]associationMatcherType: 0checkClassMatchEnable associating only the same-class objectsBooleanminMatchingScore4OverallMin total score for valid matchingFloat,
0.0 to 1.0minMatchingScore4Overall: 0.0minMatchingScore4SizeSimilarityMin bbox size similarity score for valid matchingFloat,
0.0 to 1.0minMatchingScore4SizeSimilarity: 0.0minMatchingScore4IouMin IOU score for valid matchingFloat,
0.0 to 1.0minMatchingScore4Iou: 0.0matchingScoreWeight4SizeSimilarityWeight for size similarity term in matching cost functionFloat,
0.0 to 1.0matchingScoreWeight4SizeSimilarity: 0.0matchingScoreWeight4IouWeight for IOU term in matching cost functionFloat,
0.0 to 1.0matchingScoreWeight4Iou: 1.0tentativeDetectorConfidenceIf a detection’s confidence is lower than this but higher than minDetectorConfidence, then it’s considered as a tentative detectionFloat,
0.0 to 1.0tentativeDetectorConfidence: 0.5minMatchingScore4TentativeIouMin iou threshold to match targets and tentative detectionFloat,
0.0 to 1.0minMatchingScore4TentativeIou: 0.0State EstimatorstateEstimatorTypeType of state estimator among { DUMMY=0, SIMPLE=1, REGULAR=2, SIMPLE_LOC=3 }Integer, [0,3]stateEstimatorType: 0processNoiseVar4LocProcess noise variance for bbox centerFloat,
0.0 to infprocessNoiseVar4Loc: 2.0processNoiseVar4SizeProcess noise variance for bbox sizeFloat,
0.0 to infprocessNoiseVar4Size: 1.0processNoiseVar4VelProcess noise variance for velocityFloat,
0.0 to infprocessNoiseVar4Vel: 0.1measurementNoiseVar4DetectorMeasurement noise variance for detector’s detectionFloat,
0.0 to infmeasurementNoiseVar4Detector: 4.0measurementNoiseVar4TrackerMeasurement noise variance for tracker’s localizationFloat,
0.0 to infmeasurementNoiseVar4Tracker: 16.0noiseWeightVar4LocNoise covariance weight for bbox location; if set, location noise will be proportional to box heightFloat,
>0.0 considered as setnoiseWeightVar4Loc: -0.1noiseWeightVar4VelNoise covariance weight for bbox velocity; if set, location noise will be proportional to box heightFloat,
>0.0 considered as setnoiseWeightVar4Vel: -0.1useAspectRatioUse aspect ratio in Kalman Filter’s statesBooleanuseAspectRatio: 0Object Re-IDreidTypeThe type of Re-ID network among { DUMMY=0, NvDEEPSORT=1, Reid based reassoc=2, both NvDEEPSORT and reid based reassoc=3 }Integer,
[0, 3]reidType: 0batchSizeBatch size of Re-ID networkInteger,
>0batchSize: 1workspaceSizeWorkspace size to be used by Re-ID TensorRT engine, in MBInteger,
>0workspaceSize: 20reidFeatureSizeSize of Re-ID featureInteger,
>0reidFeatureSize: 128reidHistorySizeSize of feature gallery, i.e. max number of Re-ID features kept for one trackerInteger,
>0reidHistorySize: 100inferDimsRe-ID network input dimension CHW or HWC based on inputOrderInteger,
>0inferDims: [128, 64, 3]inputOrderRe-ID network input order {NCHW=0, NHWC=1}Integer,
[0, 1]inputOrder: 1colorFormatRe-ID network input color format among {RGB=0, BGR=1 }Integer,
[0, 1]colorFormat: 0networkModeRe-ID network inference precision mode among {FP32=0, FP16=1, INT8=2 }Integer,
[0, 1, 2]networkMode: 0offsetsArray of values to be subtracted from each input channel, with length equal to number of channelsComma delimited float arrayoffsets: [0.0, 0.0, 0.0]netScaleFactorScaling factor for Re-ID network input after substracting offsetsFloat,
>0netScaleFactor: 1.0addFeatureNormalizationIf Re-ID network’s output Re-ID feature vector is not l2 normalized, explicitly performs l2 normalizationBooleanaddFeatureNormalization: 0tltEncodedModelPathname of the TAO toolkit encoded modelStringtltEncodedModel: “”tltModelKeyKey for the TAO toolkit encoded modelStringtltModelKey: “”onnxFilePathname of the ONNX model fileStringonnxFile: “”modelEngineFileAbsolute path to Re-ID engine fileStringmodelEngineFile:””calibrationTableFileAbsolute path to calibration table, required by INT8 onlyStringcalibrationTableFile:””keepAspcWhether to keep aspcect ratio when resizing input objects to Re-ID networkBooleankeepAspc: 1outputReidTensorOutput Re-ID features to user meta for downstream usageBooleanoutputReidTensor: 0useVPICropScaler (Alpha feature)Use NVIDIA’sVPI™Crop Scaler algorithm instead of built in implementationBooleanuseVPICropScaler: 0Object Model ProjectioncameraModelFilepathA list of file paths to camera info files. A valid camera info file should be provided to each video streamStringcameraModelFilepath: “”outputVisibilityOutput object visibility to object meta and file dumpBooleanoutputVisibility: 0outputFootLocationOutput object (especially for human) foot location to object meta and file dumpBooleanoutputFootLocation: 0outputConvexHullOutput projected object convex hull (especially cylinder for human) to object meta and file dumpBooleanoutputConvexHull: 1maxConvexHullSizeMaximum number of points to consist an object convex hullInteger,
>0maxConvexHullSize: 15Low-Level Tracker Comparisons and Tradeoffs#DeepStream SDK provides four reference low-level tracker libraries which have different resource requirements and performance characteristics, in terms of accuracy, robustness, and efficiency, allowing the users to choose the best tracker based on their use cases and requirements. See the following table for comparison.Gst-nvtracker Tracker library comparison#Tracker TypeGPU
ComputeCPU
ComputeProsConsBest Use CasesIOUNoVery LowLight weightNo visual features for matching, so prone to frequent tracker ID switches and failures. Not suitable for fast moving scene.Objects are sparsely located, with distinct sizesDetector is expected to run every frame or very frequently (ex. every alternate frame)NvSORTNoVery LowLight weightMotion estimation and prection with Kalman filter based state estimatorEnhanced data association with reasonable tracking accuracy with medium or high accuracy detectorsNo visual features for matching, so prone to frequent tracker ID switches and failures.Medium or high accuracy detectors such as PeopleNet and YOLODetector is expected to run every frame or very frequently (ex. every alternate frame)NvDeepSORTHighLowAllow custom Re-ID model for appearance matchingLess frequent ID switchesHighly discriminative on targets with similar appearanceHigher compute cost due to inferencing required for each objectCannot easily adjust accuracy/perf level unless switching Re-ID modelMulti-object, complex scenes even with partial occlusionObjects with similar appearanceNvDCFMediumLowHighly robust against partial occlusions, shadow, and other transient visual changesLess frequent ID switchesCan be used with PGIE interval > 0 without significant accuracy degradationOutput tracking confidence based on visual similarityEasily adjust params for accuracy-perf tradeoff depending on application requirementsSlower than IOU, NvSORT due to increased computational complexity for visual feature extractionMulti-object, complex scenes even with partial occlusionPGIE interval > 0IOU Tracker#The NvMultiObjectTracker library provides an object tracker that has only the essential and minimum set of functionalities for multi-object tracking, which is called theIOUtracker. IOU tracker performs only the following functionalities:Greedy data associationbetween the detector objects from a new video frame and the existing targets in the previous video frameTarget managementbased on the data association results including the target state update and the creation and termination of targetsThe error handling mechanisms like Late Activation and Shadow Tracking are integral part of the target management module of the NvMultiObjectTracker library; thus, such features are inherently enabled in the IOU tracker.IOU tracker can be used as a performance baseline as it consumes the minimum amount of computational resources. A sample configuration fileconfig_tracker_IOU.ymlis provided in DeepStream SDK package.NvSORT Tracker#NvSORT tracker increases the tracking accuracy while maintaining the high performance on top of IOU tracker with the following improvements:State estimationwith Kalman filter to better estimate and predict the states of the targets in the current frame.Cascaded data associationto associate targets and detector objects in multiple stages based on their proximity and confidence, which is more accurate than the simple matching in original SORT tracker.As it fully relies on the bbox attributes for data association, the NvSORT’s tracking accuracy is solely attributed to the detection accuracy. With a medium or high accuracy detector, NvSORT produces high quality tracking results with minimal computational resources. A sample configuration fileconfig_tracker_NvSORT.ymlis provided in DeepStream SDK package.NvDeepSORT Tracker#NvDeepSORT tracker utilizes deep learning based object appearance information for accurate object matching in different frames and locations, resulting in enhanced robustness over occlusions and reduced ID switches. It applies a pre-trained re-identification (Re-ID) neural network to extract a feature vector for each object, compares the similarity between different objects using the extracted feature vector with a cosine distance metric, and combines it with a state estimator to perform the data association over frames. Before running NvDeepSORT, Re-ID model needs to be set up followingSetup Sample Re-ID ModelsandCustomize Re-ID Model.Data Association#For the data association in the NvDeepSORT tracker, there are two metrics are used:ProximityRe-ID based similarityFor the proximity score, theMahalanobisdistance between thei-thdetector object and thej-thtarget is calculated using the target’s predicted location and its associated uncertainty:\[dist_{ij}=(D_i-Y_j)^TS_j^{-1}(D_i-Y_j)\]where:\(D_i\)denotes thei-thdetector object in{x,y,a,h}format.\(Y_j\)denotes the predicted states{x',y',a',h'}from state estimator for thej-thtracker.\(S_j\)denotes the predicted covariance from state estimator for thej-thtracker.In the original DeepSORT implementation, the maximum threshold ofMahalanobisdistance for a valid pair of detector object and target is set9.4877, representing 95% confidence computed from the inverse Chi-square distribution. Note in NvDeepSORT, the value is configured bythresholdMahalanobisin tracker config to achieve higher accuracy for a particular detector model, such as the PeopleNet v2.6.2, so it may be different from the value in the original implementation.After filtering out invalid pairs, the Re-ID similarity score is computed as the maximum cosine similarity between a detector object and a target. Then the cascaded data association algorithm is used for high accuracy multi-stage matching.Configuration Parameters#A sample config fileconfig_tracker_NvDeepSORT.ymlis provided in DeepStream SDK package. The following table summarizes the configuration parameters for NvDeepSORT.Gst-nvtracker NvDeepSORT low-level tracker configuration properties#ModulePropertyMeaningType and RangeDefault valueData AssociatorthresholdMahalanobisMax Mahalanobis distance based on Chi-square probabilitiesFloat,
>0 considered as setthresholdMahalanobis: -1.0minMatchingScore4ReidSimilarityMin Re-ID threshold to match targets and tentative detectionFloat,
0.0 to 1.0minMatchingScore4ReidSimilarity: 0.0matchingScoreWeight4ReIDSimilarityWeight for Re-ID similarity term in matching cost functionFloat,
0.0 to 1.0matchingScoreWeight4ReIDSimilarity: 0.0Implementation Details and Reference#The difference between NvDeepSORT and the original implementation includes:For data association, the original implementation sorts the targets in an ascending order based on the tracking age and runs the matching algorithm for each age sequentially, while NvDeepSORT applies the cascaded data association algorithm with higher performance and accuracy.NvDeepSORT implementation in the NvMultiObjectTracker library adopts the same target management policy as the NvDCF tracker, which is advanced to the original DeepSORT.The cosine distance metric for two features is\(score_{ij}=1-feature\_det_{i}\cdot feature\_track_{jk}\), with smaller values representing more similarity. By contrast, NvDeepSORT directly uses dot product for computational efficiency, so larger values means higher similarity.Reference: Wojke, Nicolai, Alex Bewley, and Dietrich Paulus. “Simple online and real-time tracking with a deep association metric.”2017 IEEE international conference on image processing (ICIP).IEEE, 2017. CheckPaperandThe original implementation on Github.NvDCF Tracker#NvDCF tracker employs a visual tracker that is based on the discriminative correlation filter (DCF) for learning a target-specific correlation filter and for localizing the same target in the next frames using the learned correlation filter. Such correlation filter learning and localization are usually carried out onper-objectbasis in a typical MOT implementation, creating a potentially large number of small CUDA kernel launches when processed on GPU. This inherently poses challenges in maximizing GPU utilization, especially when a large number of objects from multiple video streams are expected to be tracked on a single GPU.To address such performance issues, the GPU-accelerated operations for the NvDCF tracker are designed to be executed in thebatch processingmode to maximize the GPU utilization despite the nature of small CUDA kernels in per-object tracking model. The batch processing mode is applied in the entire tracking operations, including thebboxcropping and scaling, visual feature extraction, correlation filter learning, and localization. This can be viewed as a similar model to the batched cuFFT or batched cuBLAS calls, but it differs in that the batched MOT execution model spans many operations in a higher level. The batch processing capability is extended from multi-object batching to the batching of multiple streams for even greater efficiency and scalability.Thanks to its visual tracking capability, the NvDCF tracker can localize and keep track of the targets even when the detector in PGIE misses them (i.e., false negatives) for potentially an extended period of time caused by partial or full occlusions, resulting in more robust tracking. The enhanced robustness characteristics allow users to use a highermaxShadowTrackingAgevalue for longer-term object tracking and also allows PGIE’sintervalto be higher only at the cost of slight degradation in accuracy.Unlike NvSORT and NvDeepSORT where the Kalman filter takes the detection bboxes as the only input, the Kalman filter in the NvDCF tracker also takes the localization results from the visual tracking module as an input as well. Once a target is being tracked, the visual tracker keeps trying to localize the same target in the next frames using the learned correlation filter, while there could be matched detector bboxes. The Kalman filter in NvDCF tracker fuses both the DCF-based localization results and the detection bboxes for better target state estimation and prediction.Visual Tracking#For each tracked target, NvDCF tracker defines a search region around itspredictedlocation in the next frame large enough for the same target to be detected in the search region. The location of a target on a new video frame is predicted by using the state estimator module. ThesearchRegionPaddingScaleproperty determines the size of the search region as a multiple of the diagonal of the target’s bounding box. The size of the search region would be determined as:\[ \begin{align}\begin{aligned}SearchRegion_{width}=w+searchRegionPaddingScale*\sqrt{w*h}\\SearchRegion_{height}=h+searchRegionPaddingScale*\sqrt{w*h}\end{aligned}\end{align} \], where\(w\)and\(h\)are the width and height of the target’s bounding box, respectively.Once the search region is defined for each target at its predicted location, the image patches from each of the search regions are cropped and scaled to a predefined feature image size, from which the visual features are extracted. ThefeatureImgSizeLevelproperty defines the size of the feature image, and its range is from 1 to 5. Each level between 1 and 5 corresponds to 12x12, 18x18, 24x24, 30x30, and 36x36, respectively, for each feature channel. A lower value offeatureImgSizeLevelcauses NvDCF to use a smaller feature size, increasing GPU performance potentially yet at the cost of accuracy and robustness. Consider the relationship betweenfeatureImgSizeLevelandsearchRegionPaddingScalewhen configuring the parameters. IfsearchRegionPaddingScaleis increased whilefeatureImgSizeLevelis fixed, the number of pixels corresponding to the target itself in the feature images will be effectively decreased.For each cropped image patch, the visual appearance features such as ColorNames and/or Histogram-of-Oriented-Gradient (HOG) are extracted. The type of visual features to be used can be configured by settinguseColorNamesand/oruseHog. The HOG features consist of 18 channels based on the number of bins for different orientations, while The ColorNames features have 10 channels. If both features are used (by settinguseColorNames:1anduseHog:1), the total number of channels would then be 28. Therefore, if one uses both HOG and ColorNames withfeatureImgSizeLevel:5, the dimension of visual features that represents a target would be 28x48x48. The more channels of visual features are used, the higher the accuracy would be, but would increase the computational complexity and reduce the performance. The NvDCF tracker uses NVIDIA’sVPI™library for extracting those visual features.The correlation filters are generated with an attention window (using a Hanning window) applied at the center of the targetbbox. Users are allowed to move the center of the attention window in the vertical direction. For example,featureFocusOffsetFactor_y:-0.2would result in the center of the attention window to be aty=-0.2in the feature map, where the relative range of the height is[-0.5,0.5]. Consider that typical surveillance or CCTV cameras are mounted at a moderately high position to monitor a wide area of the environment, say, a retail store or a traffic intersection. From those vantage points, more occlusions can occur at the lower part of the body of persons or vehicles by other persons or vehicles. Moving the attention window up a bit may improve the accuracy and robustness for those use cases.Once a correlation filter is generated for a target, typical DCF-based trackers usually employ an exponential moving average for temporal consistency when the optimal correlation filter is created and updated over consecutive frames. The learning rate for this moving average can be configured byfilterLrandfilterChannelWeightsLrfor the correlation filters and their channel weights, respectively. The standard deviation for Gaussian for the desired response used when creating an optimal DCF filter can also be configured bygaussianSigma.Compute BackendsVisual tracker module in NvDCF supports multiple compute backends: CUDA/GPU and PVA (Programmable Vision Accelerator). So, the users are allowed to use different compute backends depending on the particular use cases.PVA is an accelerator in Tegra SOC in NVIDIA’s Jetson devices, which is specialized for image processing and computer vision algorithms with extremely low power consumption. When running DeepStream-based pipeline with tracker on Jetson, it is recommended to use the PVA-backend for DCF operations in NvDCF for better power efficiency. Since the GPU-based processing for DCF operations is offloaded onto PVA, therefore, more GPU resources are made available to the users for any downstream or custom processing that requires GPU-based processing.To employ PVA-backend, the visual tracker module leverages the APIs provided by NVIDIA’sVPI™, which can be enabled by settingvisualTrackerType:2(Alpha feature) andvpiBackend4DcfTracker:2#{CUDA=1,PVA=2}on Jetson platforms. VPI also has CUDA-backend mode, which can configured by settingvpiBackend4DcfTracker:1on any supported HW platforms (Jetson or dGPU platforms).The PVA-backend implementation of DCF operations byVPI™currently has the following limitations:The maximum number of objects that can be supported by a single instance of tracker library is 512. This translates to the following restrictions in DeepStream configuration:When sub-batching is not enabled, the total number of objects being tracked across all the streams (i.e., the number of streams in a batch *maxTargetsPerStream) should be less than or equal to 512When sub-batching is enabled, the total number of objects being tracked across all the streams in a sub-batch (i.e., the number of streams in a sub-batch *maxTargetsPerStream) should be less than or equal to 512If there areNsub-batches, the total number of objects that can be tracked in the pipeline is effectivelyN*512.Supports only one combination of the these three configurations :useColorNames:1anduseHog:1andfeatureImgSizeLevel:3Another limitation of the DCF APIs provided byVPI™is that, the max number of streams supported by a single library instance is 33. Hence, to run a DS application with higher batch size (>33) usingvisualTrackerType:2, it is recommended to useSub-batchingfeature in the tracker plugin such that each sub-batch is of size less than or equal to 33 streams.Data Association#The association of target IDs across frames for robust tracking typically entails visual appearance-based similarity matching, for which the visual appearance features are extracted at each candidate location. Usually, this is a computationally expensive process and often plays as a performance bottleneck in object tracking. Unlike existing approaches that extract visual features from all the candidate locations and perform feature matching among all the candidate objects, the NvDCF tracker takes advantage of the correlation response (that is already obtained during target localization stage) as the tracking confidence map of each tracker over a search region and simply looks up the confidence values at each candidate location (i.e., the location of each detector object) to get the visual similarity without any explicit computation. By comparing those confidences between trackers, we can identify which tracker has a higher visual similarity to a particular detector object and use it as a part of the matching score for data association. Therefore, the visual similarity matching in the data association process can be carried out very efficiently through a simple look-up table (LUT) operation on existing correlation responses.In the animated figure below, the left side shows the target within its search region, while the right side shows the correlation response map (where the deep red color indicates higher confidence and deep blue indicates lower confidence). In the confidence map, the yellow cross (i.e.,+) around the center indicates the peak location of the correlation response, while the purplexindicate the center of nearby detector bboxes. The correlation response values at those purplexlocations indicate the confidence score on how likely the same target exists at that location in terms of the visual similarity.If there are multiple detector bboxes (i.e., purplex) around the target like the one in the figure below, the data association module will take care of the matching based on the visual similairty score and the configured weight and minimum value, which arematchingScoreWeight4VisualSimilarityandminMatchingScore4VisualSimilarity, respectively.Configuration Parameters#A few sample configuration files for the NvDCF tracker are provided as a part of DeepStream SDK package, which is named as:config_tracker_NvDCF_max_perf.ymlconfig_tracker_NvDCF_perf.ymlconfig_tracker_NvDCF_accuracy.ymlThe firstmax_perfconfig file is to configure the NvDCF tracker to consume the least amount of resources, while the secondperfconfig file is for the use case where a decent balance between performance and accuracy is required. The lastaccuracyconfig file is to maximize the accuracy and robustness by enabling most of the features to their full capability, especially the target re-association.The following table summarizes the configuration parameters used in the config files for the NvDCF low-level tracker (except the common modules and parameters already mentioned in an earlier section).Gst-nvtracker NvDCF low-level tracker configuration properties#ModulePropertyMeaningType and RangeDefault valueVisual TrackervisualTrackerTypeType of visual tracker among { DUMMY=0, NvDCF=1, NvDCF_VPI=2 }NvDCF_VPI is an Alpha feature.Int, [0, 1, 2]visualTrackerType: 0useColorNamesUse ColorNames featureBooleanuseColorNames: 1useHogUse Histogram-of-Oriented-Gradient (HOG) featureBooleanuseHog: 0featureImgSizeLevelSize of a feature imageInteger,
1 to 5featureImgSizeLevel: 2featureFocusOffsetFactor_yThe offset for the center of hanning window relative to the feature heightFloat,
-0.5 to 0.5featureFocusOffsetFactor_y: 0.0useHighPrecisionFeatureWhether to use 16 bit high precision feature; otherwise use 8 bitBooleanuseHighPrecisionFeature: 0filterLrLearning rate for DCF filter in exponential moving averageFloat,
0.0 to 1.0filterLr: 0.075filterChannelWeightsLrLearning rate for weights for different feature channels in DCFFloat,
0.0 to 1.0filterChannelWeightsLr: 0.1gaussianSigmaStandard deviation for Gaussian for desired responseFloat,
>0.0gaussianSigma: 0.75vpiBackend4DcfTrackerCompute backend among {CUDA=1, PVA=2}Valid whenvisualTrackerType: 2Int, [1,2]vpiBackend4DcfTracker: 1Target ManagementsearchRegionPaddingScaleSearch region sizeInteger,
1 to 3searchRegionPaddingScale: 1minTrackerConfidenceMinimum detector confidence for a valid targetFloat,
0.0 to 1.0minTrackerConfidence: 0.6Data AssoicatorminMatchingScore4
VisualSimilarityMin visual similarity score for valid matchingFloat,
0.0 to 1.0minMatchingScore4
VisualSimilarity: 0.0matchingScoreWeight4
VisualSimilarityWeight for visual similarity term in matching cost functionFloat,
0.0 to 1.0matchingScoreWeight4
VisualSimilarity: 0.0See also theTroubleshooting in Tracker Setup and Parameter Tuningsection for solutions to common problems in tracker behavior and tuning.Miscellaneous Data Output#Miscellaneous data provides a mechanism to return additional data to the user outside of the Gst Buffer or NvDsBatchMeta. The miscellaneous data buffer will only be populated when options are enabled for specific feature. Currently the supported types of miscellaneous data are:Terminated Track ListShadow Tracking Target DataPast-frame Target DataEach type of data has a unique output variable within the miscellaneous data; however, they do share a common data structure, using the unifiedNvDsTargetMiscDataBatchdata structure. A buffer pool is used for its memory management, whose size can be set withuser-meta-pool-size. When the latency for downstream plugins to release the buffers is too long, the buffer pool may be empty so tracker will skip reporting the miscellaneous data for next batch. A warninggstnvtracker:Unabletoacquireausermetabufferwill be shown, and users can increase the pool size from default 32 to larger values like 64. Specifics for each type of miscellaneous data is defined below in the following sections.Terminated Track List#Whenever a target is terminated, the full target trajectory data can be exported to the metadata as part of the miscellaneous data, which is populated in NvDsTargetMiscDataBatch data structure. This data not only informs of the termination event of a target, but also can be useful for a downstream module that performs trajectory-based analysis for each object.The terminated track list can be saved in a file in eitherdeepstream-appor within the low-level tracker library:(Option 1) Saving output indeepstream-app:AddoutputTerminatedTracks:1in tracker configTargetManagementsectionAddterminated-track-output-dir=<dirname>indeepstream-appconfig’s application group propertiescreate the folder<dirname>Rundeepstream-appto save the terminated track history into text files in<dirname>Data format is defined below.frame numberobject unique idclass idblankblankbbox leftbbox topbbox rightbbox bottomblankblankblankblankblankblankblankconfidencetracker statevisibilityunsigned intlong unsigned intunsigned intintfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatintfloatA file will be created for each frame in each stream. Sample data is like:0 7 2 0 0.0 1535.194092 94.266541 1603.132812 301.653625 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.000000 2 1.000000
1 7 2 0 0.0 1535.938232 94.234810 1603.121338 301.769501 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.982758 2 1.000000
...(Option 2) Saving output directly from low level tracker:AddoutputTerminatedTracks:1in tracker configTargetManagementsectionAddterminatedTrackFilename:<filenameprefix>in tracker configTargetManagementsection. For example, setterminatedTrackFilename:track_dumpand the saved file names will betrack_dump_0.txt,track_dump_1.txt, etc.Rundeepstream-appto save the terminated track information directly from the low-level tracker libraryData format is defined below. The foot location, and convex hull data are only useful if SV3DT output is enabled.frame number(starting from 1)object unique idbbox leftbbox topbbox rightbbox bottomconfidenceFoot World Position XFoot World Position Yblankclass idtracker statevisibilityFoot Image Position XFoot Image Position YConvexHull Points (optional)unsigned intlong unsigned intintintintintfloatfloatfloatintunsigned intintfloatfloatfloatint separated by vertical barA file will be created for each stream. Sample data is like:# SV3DT output disabled
31,48,558,104,31,74,0.949,-1.000,-1.000,-1,0,0.994,-1,-1
32,48,558,104,31,74,0.951,-1.000,-1.000,-1,0,0.995,-1,-1
...

# SV3DT output enabled
31,48,558,104,31,74,0.949,1254.535,2962.867,-1,0,0.994,581,176,-15|-34|-14|-35|-13|-35|-10|-36|-6|-36|-3|-36|0|-36|1|-36|2|-35|16|35|15|35|13|36|9|37|6|37|3|37|0|37|0|36
32,48,558,104,31,74,0.951,1255.602,2968.294,-1,0,0.995,581,176,-14|-34|-14|-35|-13|-35|-10|-35|-6|-36|-3|-36|0|-36|1|-36|2|-35|15|35|15|35|13|36|9|37|6|37|3|37|0|37|0|36
...Shadow Tracking Target Data#As mentioned earlier, even when a target is not being associated with any of the detection bboxes, the target is still being tracked in a Shadow Tracking mode. When tracked in the Shadow Tracking mode, the target data is not being reported to the downstream because the target data may not be reliable.However, the users are allowed to still report these shadow tracking target data as a part of the miscellaneous data, whenoutputShadowTracks:1is set underTargetManagementsection in a tracker config file.The shadow tracking data can be dumped in to a file when enabled indeepstream-applike below:Addshadow-track-output-dir=<dirname>indeepstream-appconfig’s application group propertiescreate the folder<dirname>Rundeepstream-appto save the Shadow Track history into text files in<dirname>Data format is defined below.frame numberobject unique idclass idblankblankbbox leftbbox topbbox rightbbox bottomblankblankblankblankblankblankblankconfidencetracker statevisibilityunsigned intlong unsigned intunsigned intintfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatintfloatA file will be created for each frame in each stream. Sample data is like:1 11 2 0 0.0  296.346130 262.343445  333.428864  376.817291 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.407002 2 1.000000
1 22 2 0 0.0 1663.921875 857.167725 1752.483521 1049.053223 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.912138 2 1.000000
...ImportantBoth the terminated track data and the shadow tracking object data are not retained in the low-level tracker library when subsequent frames arrive. Thus, if users want to use these data, they should retrieve these miscellaneous data using theNvMOT_RetrieveMiscData()API at the end of every frame in the plugin. Otherwise, the data will be discarded within the tracker library.Past-frame Target Data#Past-frame target data is always reported in miscellaneous data, and is appended to the current frame objects in tracker KITTI dump when enabled.To enable tracker KITTI dump:Addkitti-track-output-dir=<dirname>indeepstream-appconfig’s application group propertiescreate the folder<dirname>Rundeepstream-appto save tracked objects files in<dirname>.Data format is defined below following the KITTI format. The foot location and visibility data will append to the end of each line if SV3DT output is enabled.object Labelobject Unique Idblankblankblankbbox leftbbox topbbox rightbbox bottomblankblankblankblankblankblankblankconfidencevisibility (optional)Foot Image Position X (optional)Foot Image Position Y (optional)stringlong unsignedfloatintfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatfloatA file will be created for each frame in each stream. Sample data is like:# SV3DT output disabled
person 0 0.0 0 0.0 1302.667236 135.852036 1340.975830 241.724579 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.917301
person 1 0.0 0 0.0 878.249023  195.080475  913.410950 320.695618 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.899029
...

# SV3DT output enabled
person 0 0.0 0 0.0 1302.667236 135.852036 1340.975830 241.724579 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.917301 0.966531 1314.492554 239.495193
person 1 0.0 0 0.0  878.249023 195.080475  913.410950 320.695618 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.899029 0.930824  899.187500 316.670013
...Setup and Usage of Re-ID Model#This section describes how to download and setup Re-ID models in different formats, perform INT8 calibration for performance optimization and output Re-ID features to downstream modules.Setup Sample Re-ID Models#The supported Re-ID model formats are NVIDIA TAO and ONNX. Multiple ready-to-use sample models are listed below. Scripts and README file for users to setup the model are provided insources/tracker_ReID.NoteUFF is no longer supported by TensorRT, so please migrate to TAO or ONNX models.NVIDIA TAO ReIdentificationNet#NVIDIA pre-trainedReIdentificationNetis a high accuracy ResNet-50 model with feature length 256. It can be downloaded and used directly with command:mkdir/opt/nvidia/deepstream/deepstream/samples/models/Tracker/
wget'https://api.ngc.nvidia.com/v2/models/nvidia/tao/reidentificationnet/versions/deployable_v1.0/files/resnet50_market1501.etlt'-P/opt/nvidia/deepstream/deepstream/samples/models/Tracker/The tracker config file supports this model by default. Note the raw output from this network is not L2 normalized, soaddFeatureNormalization:1is set to add L2 normalization as a post processing.ONNX Model#An open-sourced ONNX model sample isSimple Cues Lead to a Strong Multi-Object Tracker, which proposes a new Re-ID model using on-the-fly domain adaptation. The network is based on ResNet-50 with feature length being 512.mkdir/opt/nvidia/deepstream/deepstream/samples/models/Tracker/
wget'https://vision.in.tum.de/webshare/u/seidensc/GHOST/ghost_reid.onnx'-P/opt/nvidia/deepstream/deepstream/samples/models/Tracker/Then update below parameters in tracker config fileReIDsession (keepreidTypeunchanged).ReID:batchSize:100workspaceSize:1000reidFeatureSize:512reidHistorySize:100inferDims:[3,384,128]networkMode:1# [Input Preprocessing]inputOrder:0colorFormat:0offsets:[109.1250,102.6000,91.3500]netScaleFactor:0.01742919keepAspc:1# [Paths and Names]onnxFile:"/opt/nvidia/deepstream/deepstream/samples/models/Tracker/ghost_reid.onnx"Customize Re-ID Model#Users can also train a custom Re-ID model in ONNX format, whose output is a single vector for each object. Then the Re-ID similarity score will be computed based on the cosine metric and used to perform the data association in the same way as the official model. The steps are:Train a Re-ID network using deep learning frameworks such as PyTorch or TensorFlow.Make sure the network layers are supported by TensorRT and convert the model into ONNX. Mixed precision inference is still supported, and a calibration cache is required for INT8 mode.Specify the following parameters in tracker config file based on the custom model’s properties. Then run DeepStream SDK with the new Re-ID model.reidFeatureSizereidHistorySizeinferDimscolorFormatnetworkModeoffsetsnetScaleFactoraddFeatureNormalizationONNX model must specify below parameters.onnxFileRe-ID Feature Output#Objects’ Re-ID features can be accessed in the tracker plugin and downstream modules, which can be used for other tasks such as multi-target multi-camera tracking. Steps to retrieve those features usingdeepstream-appare:AddoutputReidTensor:1in tracker configReIDsection. Addreid-track-output-dir=<dirname>indeepstream-appconfig’s application group properties and create the folder<dirname>.Rundeepstream-appto save the Re-ID features in each frame into text files in<dirname>. In each text file, each line’s first integer is object id, and the remaining floats are its feature vector. Users can checkwrite_reid_track_output()indeepstream_app.cto understand how these features are retrieved.This feature is supported whenever NvDeepSORT or Re-ID based re-association is used. To retrieve Re-ID features for every frame, make sureinterval=0in PGIE config andreidExtractionInterval:0if re-association is enabled. Otherwise, the Re-ID features will be extracted at intervals only when PGIE generates bounding boxes andreidExtractionIntervalis met.Setup and Usage of Sub-batching (Alpha)#This section describes how to use thesub-batchingfeature with multiple low-level tracker config files. Two use cases are explained: the first one with varied tracker algorithms and the second one with varied compute backends.Here, adeepstream-apppipeline is used as an example.Use-case 1#This use-case illustrates an application with a batch size of 4 (i.e., 4 streams). The batch is split into 3 sub-batches: the first sub-batch of size 2 and the next two sub-batches of size 1 each. The first sub-batch uses NvDCF tracker, the second sub-batch uses NvSORT tracker, and the third sub-batch uses IOU tracker, respectively.
To achieve this, modify the[tracker]section insource4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txtconfiguration file that comes with DeepStream package as shown below :[tracker]enable=1tracker-width=960tracker-height=544ll-lib-file=/opt/nvidia/deepstream/deepstream/lib/libnvds_nvmultiobjecttracker.so

ll-config-file=config_tracker_NvDCF_accuracy.yml;config_tracker_NvSORT.yml;config_tracker_IOU.yml
sub-batches=0,1;2;3In this example,sub-batchescan also be configured using option 2 i.e.sub-batches=2:1:1. ReferGst Propertiesfor details.Use-case 2#This use-case illustrates an application with a batch size of 4, where the batch is split into 2 sub-batches each of size 2: the first sub-batch uses NvDCF tracker with  settingvisualTrackerType:1(i.e., existing DCF module). The second sub-batch uses NvDCF tracker withvisualTrackerType:2andvpiBackend4DcfTracker:2(i.e. NvDCF_VPI tracker with PVA backend). Please note that, since this use-case configures PVA backend, it will run only on Jetson platforms.Steps are :Create a copy ofconfig_tracker_NvDCF_accuracy.ymland name it asconfig_tracker_NvDCF_accuracy_PVA.ymlInconfig_tracker_NvDCF_accuracy_PVA.ymlmodify theVisualTracker:section as follows :VisualTracker:visualTrackerType:2# the type of visual tracker among { DUMMY=0, NvDCF=1,  NvDCF_VPI=2 }vpiBackend4DcfTracker:2# the type of compute backend among {CUDA=1, PVA=2}....Then modify the[tracker]section insource4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txtas follows :[tracker]enable=1tracker-width=960tracker-height=544ll-lib-file=/opt/nvidia/deepstream/deepstream/lib/libnvds_nvmultiobjecttracker.so

ll-config-file=config_tracker_NvDCF_accuracy.yml;config_tracker_NvDCF_accuracy_PVA.yml
sub-batches=0,1;2,3In this example,sub-batchescan also be configured using option 2 i.e.sub-batches=2:2. ReferGst Propertiesfor details.For further details on implementation of sub-batches feature, please refer to a writeup at the end ofnvtracker_proc.cppinnvtrackerplugin’s source code.The most optimalsub-batchesconfiguration for a pipeline depends on multiple factors like elements in the pipeline, configuration of each element, hardware configuration etc. Increasing the number of sub-batches parallelizes the processing of streams in a batch. But it also adds an overhead. Hence, the number of sub-batches to configure needs to be determined experimentally by comparing GPU/PVA utilization and performance across varioussub-batchesconfigurations. A thumb rule is to start with a single batch and keep splitting it into sub-batches until an optimal performance point is reached.Setup and Visualization of Tracker Sample Pipelines#This section describes how to setup a multi-object tracking pipeline with various NVIDIA® pre-trained detector models and DeepStream multi-object trackers, and provides ready-to-use detector and tracker config files optimized for high accuracy tracking. The optimal tracker configs for People tracking (e.g., config_tracker_NvSORT.yml, config_tracker_NvDeepSORT.yml, config_tracker_NvDCF_accuracy.yml, etc.) are already provided in DeepStream release package, so here we present optimized detector parameters only. Then the visualization of some sample outputs and internal states (such as correlation responses for a few selected targets) are presented to help users to better understand how NvDsTracker works, especially on the visual tracker module. In addition, we present detector config params and tracker config params for vehicle tracking use-case as well.People Tracking#NVIDIA® pre-trainedPeopleNetdetects person, bag, and face classes. The pre-trained model with ResNet-34 backbone is onNVIDIA NGC catalog. It can be used in PGIE module in conjunction with various low level trackers for people tracking.Setup#Heredeepstream-apppipeline is used as an example, which can be naturally extended to other applications. Steps are:Download the detector model fileshere, and place the files under/opt/nvidia/deepstream/deepstream/samples/models/peoplenetCopy detector config file in below sectionsconfig_infer_primary_PeopleNet.txtfor the specific low level tracker (for examplePeopleNet + NvDCF) into work directory:cpconfig_infer_primary_PeopleNet.txt/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-appAssumingdeepstream-appconfig file is/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/deepstream_app_config.txt, set PGIE and tracker config files in it:deepstream_app_config.txt## Other groups[primary-gie]## Use PeopleNet as PGIEconfig-file=config_infer_primary_PeopleNet.txt## Other [primary-gie] configs[tracker]## Specify the low level tracker (for example NvSORT)# ll-config-file=config_tracker_IOU.ymlll-config-file=config_tracker_NvSORT.yml# ll-config-file=config_tracker_NvDCF_perf.yml# ll-config-file=config_tracker_NvDCF_accuracy.yml# ll-config-file=config_tracker_NvDeepSORT.yml## Other [tracker] configs/opt/nvidia/deepstreamis the default DeepStream installation directory. The paths will be different if the user sets up in different directory.PeopleNet + NvSORT#This pipeline performs high performance people tracking with reasonable accuracy. Such adeepstream-apppipeline is constructed with the following components:Detector: PeopleNet v2.6.2 (w/ ResNet-34 as backbone)Post-processingalgorithm for object detection: Hybrid clustering (i.e., DBSCAN + NMS)Tracker: NvSORT withconfig_tracker_NvSORT.ymlconfiguration in DeepStream releaseA set of recommended detector config params for PeopleNet v2.6.2 to be used with NvSORT tracker is:config_infer_primary_PeopleNet.txt[property]## model-specific params. The paths will be different if the user sets up in different directory.int8-calib-file=../../models/peoplenet/resnet34_peoplenet_int8.txt
labelfile-path=../../models/peoplenet/labels.txt
onnx-file=../../models/peoplenet/resnet34_peoplenet.onnx
tlt-model-key=tlt_encode

gpu-id=0net-scale-factor=0.00392156862745098
input-dims=3;544;960process-mode=1model-color-format=0## 0=FP32, 1=INT8, 2=FP16 modenetwork-mode=1num-detected-classes=3interval=0gie-unique-id=1## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering)cluster-mode=3maintain-aspect-ratio=1[class-attrs-all]pre-cluster-threshold=0.1555
nms-iou-threshold=0.3386minBoxes=2dbscan-min-score=1.9224eps=0.3596
detected-min-w=20detected-min-h=20PeopleNet + NvDeepSORT#This pipeline enables people Re-ID capability during tracking. Such adeepstream-apppipeline is constructed with the following components:Detector: PeopleNet v2.6.2 (w/ ResNet-34 as backbone)Post-processingalgorithm for object detection: Hybrid clustering (i.e., DBSCAN + NMS)Tracker: NvDeepSORT withconfig_tracker_NvDeepSORT.ymlconfiguration in DeepStream releaseA set of recommended detector config params for PeopleNet v2.6.2 to be used with NvDeepSORT tracker is:config_infer_primary_PeopleNet.txt[property]## model-specific params. The paths will be different if the user sets up in different directory.int8-calib-file=../../models/peoplenet/resnet34_peoplenet_int8.txt
labelfile-path=../../models/peoplenet/labels.txt
onnx-file=../../models/peoplenet/resnet34_peoplenet.onnx
tlt-model-key=tlt_encode

gpu-id=0net-scale-factor=0.00392156862745098
input-dims=3;544;960process-mode=1model-color-format=0## 0=FP32, 1=INT8, 2=FP16 modenetwork-mode=1num-detected-classes=3interval=0gie-unique-id=1## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering)cluster-mode=3maintain-aspect-ratio=1[class-attrs-all]pre-cluster-threshold=0.1653
nms-iou-threshold=0.5242minBoxes=2dbscan-min-score=1.7550eps=0.1702
detected-min-w=20detected-min-h=20PeopleNet + NvDCF#This pipeline performs more accurate people tracking. For the output visualization, adeepstream-apppipeline is first constructed with the following components:Detector: PeopleNet v2.6.2 (w/ ResNet-34 as backbone)Post-processingalgorithm for object detection: Hybrid clustering (i.e., DBSCAN + NMS)Tracker: NvDCF withconfig_tracker_NvDCF_accuracy.ymlconfiguration in DeepStream releaseFor better visualization, the following changes were also made:featureImgSizeLevel:5is set underVisualTrackersection inconfig_tracker_NvDCF_accuracy.ymltracker-height=960andtracker-width=544under[tracker]section in the deepstream-app config fileA set of recommended detector config params for PeopleNet v2.6.2 to be used with NvDCF_accuracy tracker is:config_infer_primary_PeopleNet.txt[property]## model-specific params. The paths will be different if the user sets up in different directory.int8-calib-file=../../models/peoplenet/resnet34_peoplenet_int8.txt
labelfile-path=../../models/peoplenet/labels.txt
onnx-file=../../models/peoplenet/resnet34_peoplenet.onnx
tlt-model-key=tlt_encode

gpu-id=0net-scale-factor=0.00392156862745098
input-dims=3;544;960process-mode=1model-color-format=0## 0=FP32, 1=INT8, 2=FP16 modenetwork-mode=1num-detected-classes=3interval=0gie-unique-id=1## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering)cluster-mode=3maintain-aspect-ratio=1[class-attrs-all]pre-cluster-threshold=0.1429
nms-iou-threshold=0.4688minBoxes=3dbscan-min-score=0.7726eps=0.2538
detected-min-w=20detected-min-h=20The resulting output video of the aforementioned pipeline with (PeopleNet + Hybrid clustering + NvDCF) is shown below, but please note that only ‘Person’-class objects are detected and shown in the video:While the video above shows theper-streamoutput, each animated figure below shows (1) the cropped & scaled image patch used foreach targeton the left side and (2) the corresponding correlation response map for the target on the right side. As mentioned earlier, the yellow+mark shows the peak location of the correlation response map generated by using the learned correlation filter, while the puplexmarks show the the center of nearby detector objects.Person 1(w/ Blue hat + gray backpack)Person 6(w/ Red jacket + gray backpack)Person 4(w/ Green jacket)Person 5(w/ Cyan jacket)The figures above show how the correlation responses progress over time for the cases of no occlusion, partial occlusion, and full occlusions happening. It can be seen that even when a target undergoes a full occlusion for a prolonged period, the NvDCF tracker is able to keep track of the targets in many cases.IffeatureImgSizeLevel:3is used instead for better performance, the resolution of the image patch used for each target would get lower like shown in the figure below.Person 1(w/ Blue hat + gray backpack)Person 6(w/ Red jacket + gray backpack)Vehicle Tracking#To perform tracking of vehicle and other types of targets (such as pedestrians, bicycles and road signs), a NVIDIA® pre-trained detector model is available in NGC:TrafficCamNet: A newer model based on ResNet-18 backbone with higher detection accuracy onNVIDIA NGC.The following samples demonstrate usingTrafficCamNetand various trackers with different detection intervals for performance and accuracy tradeoff.Setup#Heredeepstream-apppipeline is used as an example, which can be naturally extended to other applications. Steps to setup a pipeline are:ForTrafficCamNet, download the detector model fileshere, and place the files under/opt/nvidia/deepstream/deepstream/samples/models/trafficcamnetCopy detector and tracker config files in below sections for the specific tracker type (for exampleTrafficCamNet + NvDCF) into work directory:cpconfig_infer_primary_TrafficCamNet.txt/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-appAssumingdeepstream-appconfig file is/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/deepstream_app_config.txt, set detector and tracker config files in it like the following:deepstream_app_config.txt## Other groups[primary-gie]## Use TrafficCamNet as PGIEconfig-file=config_infer_primary_TrafficCamNet.txt## Other [primary-gie] configs[tracker]## Specify the low level tracker (for example NvDCF_accuracy)# ll-config-file=config_tracker_IOU.yml# ll-config-file=config_tracker_NvSORT.yml# ll-config-file=config_tracker_NvDCF_perf.ymlll-config-file=config_tracker_NvDCF_accuracy.yml# ll-config-file=config_tracker_NvDeepSORT.yml## Other [tracker] configs/opt/nvidia/deepstreamis the default DeepStream installation directory. The paths will be different if the user sets up in different directory.TrafficCamNet + NvSORT#This pipeline performs high performance vehicle tracking with reasonable accuracy. Such adeepstream-apppipeline is constructed with the following components:Detector: TrafficCamNet v1.0.3 (w/ ResNet-18 as backbone)Post-processingalgorithm for object detection: Hybrid clustering (i.e., DBSCAN + NMS)Tracker: NvSORT with configuration as belowThe detector and tracker config files:config_infer_primary_TrafficCamNet.txt[property]## model-specific params. The paths will be different if the user sets up in different directory.int8-calib-file=../../models/trafficcamnet/resnet18_trafficcamnet_pruned_int8.txt
labelfile-path=../../models/trafficcamnet/labels.txt
onnx-file=../../models/trafficcamnet/resnet18_trafficcamnet_pruned.onnx
tlt-model-key=tlt_encode

gpu-id=0net-scale-factor=0.00392156862745098
input-dims=3;544;960process-mode=1model-color-format=0## 0=FP32, 1=INT8, 2=FP16 modenetwork-mode=1num-detected-classes=4interval=0gie-unique-id=1## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering)cluster-mode=3maintain-aspect-ratio=0[class-attrs-all]pre-cluster-threshold=0.2327
nms-iou-threshold=0.1760minBoxes=2dbscan-min-score=0.7062eps=0.4807
detected-min-w=20detected-min-h=20config_tracker_NvSORT.yml%YAML:1.0

BaseConfig:minDetectorConfidence:0.0415
TargetManagement:enableBboxUnClipping:0maxTargetsPerStream:300minIouDiff4NewTarget:0.6974minTrackerConfidence:0.8049probationAge:5maxShadowTrackingAge:42earlyTerminationAge:1TrajectoryManagement:useUniqueID:0DataAssociator:dataAssociatorType:0associationMatcherType:1checkClassMatch:1minMatchingScore4Overall:0.2042minMatchingScore4SizeSimilarity:0.2607minMatchingScore4Iou:0.3708matchingScoreWeight4SizeSimilarity:0.2639matchingScoreWeight4Iou:0.4384tentativeDetectorConfidence:0.1054minMatchingScore4TentativeIou:0.4953usePrediction4Assoc:1StateEstimator:stateEstimatorType:2noiseWeightVar4Loc:0.0853noiseWeightVar4Vel:0.0061useAspectRatio:1TrafficCamNet + NvDeepSORT#This pipeline enables vehicle Re-ID capability during tracking. Such adeepstream-apppipeline is constructed with the following components:Detector: TrafficCamNet v1.0.3 (w/ ResNet-18 as backbone)Post-processingalgorithm for object detection: Hybrid clustering (i.e., DBSCAN + NMS)Tracker: NvDeepSORT with configuration as below. No vehicle Re-ID models are included in DeepStream so far, so the user needs to followCustomize Re-ID Modelto setup a vehicle Re-ID model and changeReIDsection in tracker config.The detector and tracker config files:config_infer_primary_TrafficCamNet.txt[property]## model-specific params. The paths will be different if the user sets up in different directory.int8-calib-file=../../models/trafficcamnet/resnet18_trafficcamnet_pruned_int8.txt
labelfile-path=../../models/trafficcamnet/labels.txt
onnx-file=../../models/trafficcamnet/resnet18_trafficcamnet_pruned.onnx
tlt-model-key=tlt_encode

gpu-id=0net-scale-factor=0.00392156862745098
input-dims=3;544;960process-mode=1model-color-format=0## 0=FP32, 1=INT8, 2=FP16 modenetwork-mode=1num-detected-classes=4interval=0gie-unique-id=1## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering)cluster-mode=3maintain-aspect-ratio=0[class-attrs-all]pre-cluster-threshold=0.1654
nms-iou-threshold=0.7614minBoxes=3dbscan-min-score=2.4240eps=0.3615
detected-min-w=20detected-min-h=20config_tracker_NvDeepSORT.yml%YAML:1.0

BaseConfig:minDetectorConfidence:0.0451
TargetManagement:preserveStreamUpdateOrder:0maxTargetsPerStream:150minIouDiff4NewTarget:0.0602minTrackerConfidence:0.7312probationAge:9maxShadowTrackingAge:59earlyTerminationAge:1TrajectoryManagement:useUniqueID:0DataAssociator:dataAssociatorType:0associationMatcherType:1checkClassMatch:1thresholdMahalanobis:34.3052minMatchingScore4Overall:0.0231minMatchingScore4SizeSimilarity:0.3104minMatchingScore4Iou:0.3280minMatchingScore4ReidSimilarity:0.6805matchingScoreWeight4SizeSimilarity:0.7103matchingScoreWeight4Iou:0.5429matchingScoreWeight4ReidSimilarity:0.6408tentativeDetectorConfidence:0.0483minMatchingScore4TentativeIou:0.5093
StateEstimator:stateEstimatorType:2noiseWeightVar4Loc:0.0739noiseWeightVar4Vel:0.0097useAspectRatio:1ReID:# need customizationreidType:1batchSize:100workspaceSize:1000reidFeatureSize:128reidHistorySize:100inferDims:[128,64,3]networkMode:0inputOrder:1colorFormat:0offsets:[0.0,0.0,0.0]netScaleFactor:1.0000keepAspc:1# custom Re-ID model pathTrafficCamNet + NvDCF#This pipeline performs more accurate vehicle tracking. For the output visualization, adeepstream-apppipeline is first constructed with the following components:Detector: TrafficCamNet v1.0.3 (w/ ResNet-18 as backbone)Post-processingalgorithm for object detection: Hybrid clustering (i.e., DBSCAN + NMS)Tracker: NvDCF with configuration as below. No vehicle Re-ID models are included in DeepStream so far, so the user needs to followCustomize Re-ID Modelto setup a vehicle Re-ID model and changeReIDsection in tracker config.The detector and tracker config files:config_infer_primary_TrafficCamNet.txt[property]## model-specific params. The paths will be different if the user sets up in different directory.int8-calib-file=../../models/trafficcamnet/trafficcamnet_int8.txt
labelfile-path=../../models/trafficcamnet/labels.txt
tlt-encoded-model=../../models/trafficcamnet/resnet18_trafficcamnet_pruned.etlt
tlt-model-key=tlt_encode

gpu-id=0net-scale-factor=0.00392156862745098
input-dims=3;544;960uff-input-blob-name=input_1
process-mode=1model-color-format=0## 0=FP32, 1=INT8, 2=FP16 modenetwork-mode=1num-detected-classes=4interval=0gie-unique-id=1output-blob-names=output_cov/Sigmoid;output_bbox/BiasAdd## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering)cluster-mode=3maintain-aspect-ratio=0[class-attrs-all]pre-cluster-threshold=0.3034
nms-iou-threshold=0.5002minBoxes=3dbscan-min-score=1.2998eps=0.1508
detected-min-w=20detected-min-h=20config_tracker_NvDCF_accuracy.yml%YAML:1.0

BaseConfig:minDetectorConfidence:0.0382
TargetManagement:enableBboxUnClipping:0preserveStreamUpdateOrder:0maxTargetsPerStream:150minIouDiff4NewTarget:0.1356minTrackerConfidence:0.2136probationAge:1maxShadowTrackingAge:49earlyTerminationAge:1TrajectoryManagement:useUniqueID:0enableReAssoc:1minMatchingScore4Overall:0.0324minTrackletMatchingScore:0.2979minMatchingScore4ReidSimilarity:0.4329matchingScoreWeight4TrackletSimilarity:0.5117matchingScoreWeight4ReidSimilarity:0.8356minTrajectoryLength4Projection:14prepLength4TrajectoryProjection:50trajectoryProjectionLength:116maxAngle4TrackletMatching:180minSpeedSimilarity4TrackletMatching:0minBboxSizeSimilarity4TrackletMatching:0.2154maxTrackletMatchingTimeSearchRange:16trajectoryProjectionProcessNoiseScale:0.0100trajectoryProjectionMeasurementNoiseScale:100trackletSpacialSearchRegionScale:0.0742reidExtractionInterval:2enableVanishingTrackletReconstruction:0minInclusionRatio4DuplicateTrackletRemoval:0.5705minIou4DuplicateTrackletRemoval:0.5260minMatchRatio4ValidTrackletDetermination:0.4385minVisibility4VanishingTrackletReconstruction:0.3485visibilityThreshold4VanishingTrackletDetection:0.5817DataAssociator:dataAssociatorType:0associationMatcherType:1checkClassMatch:1minMatchingScore4Overall:0.1103minMatchingScore4SizeSimilarity:0.0392minMatchingScore4Iou:0.0980minMatchingScore4VisualSimilarity:0.3234matchingScoreWeight4VisualSimilarity:0.4223matchingScoreWeight4SizeSimilarity:0.8416matchingScoreWeight4Iou:0.6517tentativeDetectorConfidence:0.0198minMatchingScore4TentativeIou:0.1844
StateEstimator:stateEstimatorType:1processNoiseVar4Loc:374.6508processNoiseVar4Size:3364.1350processNoiseVar4Vel:3.6082measurementNoiseVar4Detector:164.4517measurementNoiseVar4Tracker:3439.5683
VisualTracker:visualTrackerType:1useColorNames:1useHog:1featureImgSizeLevel:4featureFocusOffsetFactor_y:0.0652filterLr:0.0993filterChannelWeightsLr:0.0549gaussianSigma:0.9047
ReID:# need customizationreidType:2batchSize:100workspaceSize:1000reidFeatureSize:128reidHistorySize:148inferDims:[128,64,3]networkMode:0inputOrder:1colorFormat:0offsets:[0.0,0.0,0.0]netScaleFactor:1.0000keepAspc:1# onnxFile: customize_onnx_pathBelow is a side-by-side comparison of TrafficCamNet with different trackers on a challenging scene with lots of occlusions. From the top-left corner in the clockwise direction are detection only, NvSORT, NvDeepSORT, and NvDCF results. NvDCF has the highest tracking accuracy and robustness to occlusion.Tracker Accuracy Tuning#Tracker sample pipelines demonstrated in above section include lots of detector and tracker parameters optimized for people tracking. When users deploy such pipelines for other scenarios, such as traffic, animals, etc., a pain point is how to find the optimal parameters with the highest accuracy KPI for each use case. Manual parameter tuning requires in-depth knowledge on the tracker algorithm and how each parameter would affect the functionality. Given the large number of parameters, the complexity of such process would increase exponentially.Starting from DeepStream 7.0, a new toolPipeTuneris released to allow automatic accuracy tuning. It efficiently explores the (potentially very high-dimensional) parameter space and automatically finds the optimal parameters for the pipelines, which yields the highest KPI on the dataset. Base on their use case, users can tune the tracker on public multi-object tracking datasets, such asMOT Challenge,KITTI, or create their own dataset with sample videos and ground truth (bounding box and object ID). Users can select common tracking accuracy metrics includingHOTA,MOTAandIDF1as the KPI. VisitAccuracy Tuning Toolson how to setup PipeTuner and start DeepStream tracker accuracy tuning.How to Implement a Custom Low-Level Tracker Library#To write a custom low-level tracker library, users are expected to implement the API defined insources/includes/nvdstracker.h, which is covered in an earlier section onNvDsTracker API, and parts of the API refer tosources/includes/nvbufsurface.h. Thus, the users would need to includenvdstracker.hto implement the API:#include"nvdstracker.h"Below is a sample implementation of each API. Assuming that the low-level tracker library defines and implements a custom class (e.g.,NvMOTContextclass in the sample code below) to perform actual operations corresponding to each API call. Below is a sample code for initialization and de-initialization APIs:NoteThe sample code below have some skeletons only. Users are expected to add proper error handling and additional codes as neededNvMOTStatusNvMOT_Init(NvMOTConfig*pConfigIn,NvMOTContextHandle*pContextHandle,NvMOTConfigResponse*pConfigResponse){if(pContextHandle!=nullptr){NvMOT_DeInit(*pContextHandle);}/// User-defined class for the contextNvMOTContext*pContext=nullptr;/// Instantiate the user-defined contextpContext=newNvMOTContext(*pConfigIn,*pConfigResponse);/// Pass the pointer as the context handle*pContextHandle=pContext;/*** return NvMOTStatus_Error if something is wrong* return NvMOTStatus_OK if everything went well*/}/*** This is a sample code for the constructor of `NvMOTContext`* to show what may need to happen when NvMOTContext is instantiated in the above code for `NvMOT_Init` API*/NvMOTContext::NvMOTContext(constNvMOTConfig&config,NvMOTConfigResponse&configResponse){// Set CUDA device as neededcudaSetDevice(m_Config.miscConfig.gpuId)// Instantiate an appropriate localizer/tracker implementation// Load and parse the config file for the low-level tracker using the path to a config filem_pLocalizer=LocalizerFactory::getInstance().makeLocalizer(config.customConfigFilePath);// Set max # of streams to be supported// ex) uint32_t maxStreams = config.maxStreams;// Use the video frame infofor(uinti=0;i<m_Config.numTransforms;i++){// Use the expected color format from the input source imagesNvBufSurfaceColorFormatconfigColorFormat=(NvBufSurfaceColorFormat)m_Config.perTransformBatchConfig[i].colorFormat;// Use the frame width, height, and pitch as neededuint32_tframeHeight=m_Config.perTransformBatchConfig[i].maxHeight;uint32_tframeWidth=m_Config.perTransformBatchConfig[i].maxWidth;uint32_tframePitch=m_Config.perTransformBatchConfig[i].maxPitch;/* Add here to pass the frame info to the low-level tracker */}// Set if everything goes wellconfigResponse.summaryStatus=NvMOTConfigStatus_OK;}voidNvMOT_DeInit(NvMOTContextHandlecontextHandle){/// Destroy the context handledeletecontextHandle;}During the initialization stage (whenNvMOT_Init()is called), the context for the low-level tracker is expected to be instantiated, and its pointer is passed as the context handle (i.e.,pContextHandle) as the output as well as the output status inpConfigResponse. Users may allocate memories based on the information about the video frames (e.g., width, height, pitch, and colorFormat) and streams (e.g., max # of streams) from the inputNvMOTConfig*pConfigIn, where the definition of the structNvMOTConfigcan be found innvdstracker.h. The path to the config file for the low-level tracker library inpConfigIn->customConfigFilePathcan be also used to parse the config file to initialize the low-level tracker library.After initialization is finished, the tracker plugin queries parameters needed from low-level tracker library. The query function needs to be implemented like below:NvMOTStatusNvMOT_Query(uint16_tcustomConfigFilePathSize,char*pCustomConfigFilePath,NvMOTQuery*pQuery){/*** Users can parse the low-level config file in pCustomConfigFilePath to check* the low-level tracker's requirements*//** An optional function queryParams(NvMOTQuery&) can be implemented in context handle to fill query params. *//*if (pQuery->contextHandle){pQuery->contextHandle->queryParams(*pQuery);}*//**  Required configs for all custom trackers. */pQuery->computeConfig=NVMOTCOMP_GPU;// among {NVMOTCOMP_GPU, NVMOTCOMP_CPU}pQuery->numTransforms=1;// 0 for IOU and NvSORT tracker, 1 for NvDCF or NvDeepSORT tracker as they require the video framespQuery->supportPastFrame=true;// Set true only if the low-level tracker supports the past-frame datapQuery->batchMode=NvMOTBatchMode_Batch;// batchMode must be set as NvMOTBatchMode_BatchpQuery->colorFormats[0]=NVBUF_COLOR_FORMAT_NV12;// among {NVBUF_COLOR_FORMAT_NV12, NVBUF_COLOR_FORMAT_RGBA}#ifdef __aarch64__pQuery->memType=NVBUF_MEM_DEFAULT;#elsepQuery->memType=NVBUF_MEM_CUDA_DEVICE;#endif// among {NVBUF_MEM_DEFAULT, NVBUF_MEM_CUDA_DEVICE, NVBUF_MEM_CUDA_UNIFIED, NVBUF_MEM_CUDA_PINNED, ... }pQuery->maxTargetsPerStream=150;// Max number of targets stored for each stream/** Optional configs to set for additional features. */pQuery->maxShadowTrackingAge=30;// Maximum length of shadow tracking, required if supportPastFrame is truepQuery->outputReidTensor=true;// Set true only if the low-level tracker supports outputting reid featurepQuery->reidFeatureSize=256;// Size of Re-ID feature, required if outputReidTensor is true/*** return NvMOTStatus_Error if something is wrong* return NvMOTStatus_OK if everything went well*/}Once the low-level tracker library creates the tracker context and performs query during the initialization stage, it needs to implement a function to process each frame batch, which isNvMOT_Process(). Make sure to set the stream ID properly in the output so thatpParams->frameList[i].streamIDmatches withpTrackedObjectsBatch->list[j].streamIDif they are for the same stream, regardless ofiandj. The methodNvMOTContext::processFrame()in the sample code below is expected to perform the required multi-object tracking operations with the input data of the video frames and the detector object information, while reporting the tracking outputs inNvMOTTrackedObjBatch*pTrackedObjectsBatch.Users can refer toAccessing NvBufSurface memory in OpenCVto know more about how to access the pixel data in the video frames.NvMOTStatusNvMOT_Process(NvMOTContextHandlecontextHandle,NvMOTProcessParams*pParams,NvMOTTrackedObjBatch*pTrackedObjectsBatch){/// Process the given video frame using the user-defined method in the context, and generate outputscontextHandle->processFrame(pParams,pTrackedObjectsBatch);/*** return NvMOTStatus_Error if something is wrong* return NvMOTStatus_OK if everything went well*/}/*** This is a sample code for the method of `NvMOTContext::processFrame()`* to show what may need to happen when it is called in the above code for `NvMOT_Process` API*/NvMOTStatusNvMOTContext::processFrame(constNvMOTProcessParams*params,NvMOTTrackedObjBatch*pTrackedObjectsBatch){// Make sure the input frame is valid according to the MOT Config used to create this contextfor(uintstreamInd=0;streamInd<params->numFrames;streamInd++){NvMOTFrame*motFrame=&params->frameList[streamInd];for(uinti=0;i<motFrame->numBuffers;i++){/* Add something here to check the validity of the input using the following info*/motFrame->bufferList[i]->widthmotFrame->bufferList[i]->heightmotFrame->bufferList[i]->pitchmotFrame->bufferList[i]->colorFormat}}// Construct the mot input framesstd::map<NvMOTStreamId,NvMOTFrame*>nvFramesInBatch;for(NvMOTStreamIdstreamInd=0;streamInd<params->numFrames;streamInd++){NvMOTFrame*motFrame=&params->frameList[streamInd];nvFramesInBatch[motFrame->streamID]=motFrame;}if(nvFramesInBatch.size()>0){// Perform update and construct the output data insidem_pLocalizer->update(nvFramesInBatch,pTrackedObjectsBatch);/*** The call m_pLocalizer->update() is expected to properly populate the ouput (i.e., `pTrackedObjectsBatch`).** One thing to not forget is to fill `pTrackedObjectsBatch->list[i].list[j].associatedObjectIn`, where* `i` and `j` are indices for stream and targets in the list, respectively.* If the `j`th target was associated/matched with a detector object,* then `associatedObjectIn` is supposed to have the pointer to the associated detector object.* Otherwise, `associatedObjectIn` shall be set NULL.*/}}The low-level tracker can send miscellaneous data to the tracker plugin byNvMOT_RetrieveMiscData()API. Here past frame data is used as an example. Other types of customized miscellaneous data can be added inNvMOTTrackerMiscDatastruct and also be outputted inretrieveMiscData.NvMOTStatusNvMOT_RetrieveMiscData(NvMOTContextHandlecontextHandle,NvMOTProcessParams*pParams,NvMOTTrackerMiscData*pTrackerMiscData){/// Retrieve the past-frame data if there arecontextHandle->retrieveMiscData(pParams,pTrackerMiscData);/*** return NvMOTStatus_Error if something is wrong* return NvMOTStatus_OK if everything went well*/}/*** This is a sample code for the method of `NvMOTContext::processFramePast()`* to show what may need to happen when it is called in the above code for `NvMOT_ProcessPast` API*/NvMOTStatusNvMOTContext::retrieveMiscData(constNvMOTProcessParams*params,NvMOTTrackerMiscData*pTrackerMiscData){std::set<NvMOTStreamId>videoStreamIdList;///\ Indiate what streams we want to fetch past-frame datafor(NvMOTStreamIdstreamInd=0;streamInd<params->numFrames;streamInd++){videoStreamIdList.insert(params->frameList[streamInd].streamID);}///\ Retrieve past frame dataif(pTrackerMiscData&&pTrackerMiscData->pPastFrameObjBatch){m_pLocalizer->outputPastFrameObjs(videoStreamIdList,pTrackerMiscData->pPastFrameObjBatch);}/*** Add other types of miscellaneous data here*/}For the cases where the video stream sources are dynamically removed and added, the API callNvMOT_RemoveStreams()can be implemented to clean-up the resources no longer needed.NvMOTStatusNvMOT_RemoveStreams(NvMOTContextHandlecontextHandle,NvMOTStreamIdstreamIdMask){/// Remove the specified video stream from the low-level tracker contextcontextHandle->removeStream(streamIdMask);/*** return NvMOTStatus_Error if something is wrong* return NvMOTStatus_OK if everything went well*/}/*** This is a sample code for the method of `NvMOTContext::removeStream()`* to show what may need to happen when it is called in the above code for `NvMOT_RemoveStreams` API*/NvMOTStatusNvMOTContext::removeStream(constNvMOTStreamIdstreamIdMask){m_pLocalizer->deleteRemovedStreamTrackers(streamIdMask);}In sum, to work with theNvDsTrackerAPIs, users may want to defineclassNvMOTContextlike below to implement the methods in the code above. The actual implementation of each method may differ depending on the tracking algorithm the user choose to implement./*** @brief Context for input video streams** The stream context holds all necessary state to perform multi-object tracking* within the stream.**/classNvMOTContext{public:NvMOTContext(constNvMOTConfig&configIn,NvMOTConfigResponse&configResponse);~NvMOTContext();/*** @brief Process a batch of frames** Internal implementation of NvMOT_Process()** @param [in] pParam Pointer to parameters for the frame to be processed* @param [out] pTrackedObjectsBatch Pointer to object tracks output*/NvMOTStatusprocessFrame(constNvMOTProcessParams*params,NvMOTTrackedObjBatch*pTrackedObjectsBatch);/*** @brief Output the miscellaneous data if there are**  Internal implementation of retrieveMiscData()** @param [in] pParam Pointer to parameters for the frame to be processed* @param [out] pTrackerMiscData Pointer to miscellaneous data output*/NvMOTStatusretrieveMiscData(constNvMOTProcessParams*params,NvMOTTrackerMiscData*pTrackerMiscData);/*** @brief Terminate trackers and release resources for a stream when the stream is removed**  Internal implementation of NvMOT_RemoveStreams()** @param [in] streamIdMask removed stream ID*/NvMOTStatusremoveStream(constNvMOTStreamIdstreamIdMask);protected:/*** Users can include an actual tracker implementation here as a member* `IMultiObjectTracker` can be assumed to an user-defined interface class*/std::shared_ptr<IMultiObjectTracker>m_pLocalizer;};previousGst-nvinferservernextGst-nvstreammuxOn this pageSub-batching (Alpha)Inputs and OutputsGst PropertiesNvDsTracker API for Low-Level Tracker LibraryNvMultiObjectTracker: A Reference Low-Level Tracker LibraryUnified Tracker Architecture for Composable Multi-Object TrackerWorkflow and Core Modules in TheNvMultiObjectTrackerLibraryData AssociationTarget Management and Error HandlingState EstimationObject Re-IdentificationTarget Re-AssociationBounding-box UnclippingSingle-View 3D Tracking (Alpha)The 3x4 Camera Projection MatrixConfiguration ParametersLow-Level Tracker Comparisons and TradeoffsIOU TrackerNvSORT TrackerNvDeepSORT TrackerData AssociationConfiguration ParametersImplementation Details and ReferenceNvDCF TrackerVisual TrackingData AssociationConfiguration ParametersMiscellaneous Data OutputTerminated Track ListShadow Tracking Target DataPast-frame Target DataSetup and Usage of Re-ID ModelSetup Sample Re-ID ModelsNVIDIA TAO ReIdentificationNetONNX ModelCustomize Re-ID ModelRe-ID Feature OutputSetup and Usage of Sub-batching (Alpha)Use-case 1Use-case 2Setup and Visualization of Tracker Sample PipelinesPeople TrackingSetupPeopleNet + NvSORTPeopleNet + NvDeepSORTPeopleNet + NvDCFVehicle TrackingSetupTrafficCamNet + NvSORTTrafficCamNet + NvDeepSORTTrafficCamNet + NvDCFTracker Accuracy TuningHow to Implement a Custom Low-Level Tracker LibraryPrivacy Policy|Manage My Privacy|Do Not Sell or Share My Data|Terms of Service|Accessibility|Corporate Policies|Product Security|ContactCopyright © 2024-2025, NVIDIA Corporation.Last updated on Jan 13, 2025.